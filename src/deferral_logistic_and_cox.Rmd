---
title: "Logistic regression for deferral"
author: "Jarkko Toivonen"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
always_allow_html: true
output: 
  github_document:
    toc: true
    toc_depth: 3
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GGally)
#library(safeBinaryRegression)
library(detectseparation)  # This is better than the above package
library(brms)
library(tidybayes)
library(bayesplot)
library(posterior)
library(survival)
library(survminer)
library(ggfortify)
library(ggridges)
library(tictoc)
library(knitr)
library(kableExtra)
library(skimr)

recompute_dosages <- FALSE
recompute_survival <- FALSE
recompute_linearity_check <- FALSE
recompute <- FALSE
save_figs <- FALSE
#base <- "~/FRCBS/blood_health_phewas/logistic_regression"
base <- "../logistic_regression"
fig_path <- sprintf("%s/figures", base)
table_path <- sprintf("%s/tables", base)
source("common.R")

# This can measure time a chunk took to execute.
# Add chunk option time_it=TRUE to each chunk your want to measure.
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- lubridate::now()
    } else {
      # calculate the time difference after a chunk
      res <- lubridate::now() - now
      # return a character string to show the time
      msg <- paste("Time for this code chunk to run:", as.numeric(res), units(res))
      message(msg)
      NULL   # Don't return the message so that it won't be printed to the resulting document.
      msg
    }
  }
}))
knitr::opts_chunk$set(echo=TRUE, time_it=TRUE)

myscale <- function(v) { return((v - mean(v, na.rm = TRUE)) / sd(v, na.rm = TRUE))}

```

# Helper functions

```{r Demographic group color palette}
# Get five equally spaced hue, and reorder so that males are blue and females are red.
# And keep this palette fixed, even if some groups are missing from some plots.
gg_color_hue <- function(n) {   # Gives 'n' equally spaced hues
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
b <- gg_color_hue(5)
cohort_colors <- c(all = b[5], male = b[4], female = b[1], pre_menopausal_female=b[2], post_menopausal_female=b[3])

```

```{r Color p-values in tables}
# Emphasize cells whose value is below the significance threshold
conditional_format <- function(c) {
  alpha <- 0.05
  cell_spec(format(c, scientific=TRUE, digits=3), 
            background = ifelse(is.na(c) | c >= alpha, "white", "red")) 
}
pvalue_table <- function(df) {
  df %>% 
    mutate(across(any_of(names(cohort_colors)), conditional_format)) %>% 
    #mutate(all = conditional_format(all)) %>% 
    kable(escape = FALSE) %>% 
    #kable(escape = FALSE, format.args = list(scientific=TRUE, digits=3)) %>% 
    kable_styling()
}
```

```{r}
# Input is a dataframe that has a factor column whose name is given as parameter
# Returns a dataframe with two columns
# stripe column has alternating values 0 and 1
# the other column contains the levels of the specified column
make_stripes <- function(df, Variable) {
  v <- df %>% pull({{Variable}})
  if (is.factor(v)) {
    v <- levels(v)
  } else {
    v <- sort(unique(v))
  }
  tibble({{Variable}} := factor(v, levels=v)) %>% 
     mutate(stripe = row_number() %% 2)
}

geom_stripes <- function(df, Variable) {
  geom_rect(data=make_stripes(df, Variable) %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Variable) + 0.5,
                        ymin = as.numeric(Variable) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE)
}
```

# Todo

* Use the usual definition for deferral, not the one we are using in the international Hb project
* Try to bootstrap the confidence intervals. NO NEED TO. THEY'LL PROBABLY LOOK LIKE THE NORMAL CIS.
* Survival analysis of deferral
* ALMOST READY Logistic regression for anemia (and survival?)
* Why Cox diagnostic plot look biparted?


# Logistic regression for deferral

## Get datas

### Get genotype data

```{r, time_it=TRUE}
snips2 <- read_tsv("~/proj/blood_health_phewas/metaresults_finngen_R_D3_ANAEMIA_IRONDEF_lead.tsv")
# snips <- tribble(
#   ~chr, ~pos, ~ref, ~alt, ~gene,
#    1, 169549811, "C", "T", "F5",
#    6,  32617727, "G", "C", "HLA-DQA1",
#   15,  45095352, "A", "G", "DUOX2",
#   17,  58358769, "C", "T", "RNF43"
# )
snips <- snips2 %>% 
  group_by(chrom) %>% 
  slice_min(order_by=pval) %>%   # Take snip with smallest p-value from each chromosome
  ungroup() %>% 
  slice_min(order_by=pval, n=4) %>%
  rename(chr=chrom)
write_tsv(snips, file = "~/FRCBS/anemia_and_deferral_article/table/anemia_meta_top_four.tsv")
openxlsx::write.xlsx(snips, file = "~/FRCBS/anemia_and_deferral_article/table/anemia_meta_top_four.xlsx", overwrite=TRUE)
knitr::kable(snips)
```

```{r}
# Returns a dataframe with one row where columns are the genotypes of individuals 
get_snip <- function(chr, pos) {
  dir <- "/home/toivoja/data/private/finngen"
  #filename <- sprintf("%s/finngen_R4_bb_chr%i_BLOOD_SERVICE_extracted_*_donor.vcf.gz", dir, chr) # R4
  #filename <- Sys.glob(filename)  # Expand the wildcard '*'
  filename <- sprintf("%s/R5/BB_finngen_R7_chr%i_BLOOD_SERVICE_BB_extracted_consentdonors.vcf.gz", dir, chr) # R5
  result_filename <- sprintf("/tmp/poista-%i.tsv", chr)
  cmd <- sprintf("bcftools query -f 'chr\tpos\t[%%SAMPLE\t]\n%%CHROM\t%%POS\t[%%TGT\t]\n' %s -r chr%i:%i > %s",
                 filename,
                 chr,
                 pos,
                 result_filename)
  print(cmd)
  system(cmd)
  df <- read_tsv(result_filename)
  df <- df %>% mutate(chr=as.numeric(str_remove(chr, "chr")))
  df <- df[-ncol(df)]  # Drop the empty last column
  return(df)
}

# Dosages is a dataframe with one column for each snip
#dosages_filename <- "~/proj/blood_health_phewas/R4_dosages.tsv"
dosages_filename <- "~/proj/blood_health_phewas/R5_dosages.tsv"
if (recompute_dosages | !file.exists(dosages_filename)) {
  df2 <- snips %>% select(chr, pos) %>% pmap_dfr(function(chr, pos) get_snip(chr, pos))
  df3 <- df2 %>% 
    pivot_longer(cols=-c(chr, pos), names_to = "donor", values_to = "genotype") %>%
    inner_join(snips) %>% 
    mutate(dosage=str_count(genotype, alt))
  dosages <- df3 %>% pivot_wider(values_from = dosage, names_from=c(chr, pos), names_prefix="snp_", id_cols = donor)
  write_tsv(dosages, dosages_filename)
} else {
  dosages <- read_tsv(dosages_filename)
}
```

```{r}
# This snip seems to have its major and minor alleles in wrong way
dosages <- dosages %>% mutate(snp_15_45095352 = 2-snp_15_45095352)
```


Do the dosages look sane? Yes.

```{r}
summary(dosages %>% mutate(across(-donor, as.factor)))
```

### PRS

```{r Get anemia weights, eval=FALSE}
anemia_weights <- read_tsv("~/proj/blood_health_phewas/prs/D3_ANAEMIA_IRONDEF.weights.txt", col_names = FALSE)
summary(anemia_weights)
g <- anemia_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Anemia weight")
g
```

```{r Get ferritin weights, eval=FALSE}
ferritin_weights <- read_tsv("~/proj/blood_health_phewas/prs/IronhomeostasisFerritinAllInterval_IasterDX_2018-11-06.wInfo.cl.txt.weights.txt", col_names = FALSE)
summary(ferritin_weights)
g <- ferritin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Ferritin weight")
g
```

```{r Get hemoglobin weights, eval=FALSE}
hemoglobin_weights <- read_tsv("~/proj/blood_health_phewas/prs/32888494-GCST90002384-EFO_0004509.h.tsv.weights.txt", col_names = FALSE)
summary(hemoglobin_weights)
g <- hemoglobin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Hemoglobin weight")
g
```

```{r Get PRS scores, results='hide', message=FALSE}
get_scores <- function(phenotype) { 
  #filenames <- sprintf("~/proj/blood_health_phewas/prs/R4_chr%i.profile", 1:22)
  filenames <- sprintf("~/proj/blood_health_phewas/prs/R5/R5_%s_%i.profile", phenotype, 1:22)
  names(filenames) <- sprintf("chr%i", 1:22)
  df <- map_dfr(filenames, 
                function(filename) {
                  read_table(filename, col_types = cols()) %>% select(donor=IID, {{phenotype}}:=SCORE)
                }, 
                .id="chr")
  scores <- df %>% group_by(donor) %>% summarise(across({{phenotype}}, sum))
  return(scores)
}
anemia_scores <- get_scores("anemia") %>% rename(prs_anemia=anemia)
ferritin_scores <- get_scores("ferritin") %>% rename(prs_ferritin=ferritin)
hemoglobin_scores <- get_scores("hemoglobin") %>% rename(prs_hemoglobin=hemoglobin)
scores <- anemia_scores %>% inner_join(ferritin_scores) %>% inner_join(hemoglobin_scores)
```

```{r Example plot of PRS bottom and top deciles}
# This is for presentation
g <- scores %>% 
  ggplot(aes(x=prs_anemia)) + 
  geom_histogram() + 
  geom_vline(xintercept = quantile(scores$prs_anemia, c(0.1, 0.9)), color="red") +
  labs(x="PRS anemia")
if (save_figs) {
  filename <- sprintf("%s/anemia_prs.png", fig_path)
  ggsave(filename=filename,  width = 90,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}
g
```


### Get Finngen

```{r}

finngen <- get_finngen()
finngen <- finngen %>% 
  mutate(bmi = weight / (height / 100)**2,
         smoking=ifelse(smoking %in% c("yes, occassionally", "yes, regularly"), TRUE, FALSE))
```

### Get donation information

```{r}
#donations2 <- readRDS("~/proj/interval_prediction/data/preprocessed-29-7-2021.rds")
donations2 <- readRDS("~/proj/blood_health_phewas/preprocessed_and_labeled.rds")
```


```{r}
donations <- donations2 %>% 
  mutate(female = sex == "female") %>% 
  select(-sex) %>%
  mutate(warm_season = as.logical(warm_season)) %>%
  replace_na(list(nb_donat_progesa=0, nb_donat_outside=0)) %>%
  mutate(nb_donat_outside = ifelse(nb_donat_outside < 0.0, 0.0, nb_donat_outside)) %>%
  mutate(nb_donat = nb_donat_progesa + nb_donat_outside) %>% 
  mutate(group = factor(case_when(!female ~ "male",
                                  female & age < 45 ~ "pre_menopausal_female",
                                  female & age >= 45 ~ "post_menopausal_female"))) %>% 
  arrange(dateonly) %>% 
  group_by(donor) %>% 
  mutate(donation_count = lag(cumsum(donat_phleb == "K"), default=0)) %>% 
  ungroup()
```




```{r Donation summary}
summary(donations)
```

```{r Donation summary plots}
filename <- sprintf("%s/donation_summary_plot.png", fig_path)
if (recompute | !file.exists(filename)) {
  tmp <- donations %>% select(where(~ is.numeric(.x) || is.logical(.x))) %>% pivot_longer(cols = everything() ) 
  g <- tmp %>% ggplot(aes(value)) + 
    geom_histogram() + 
    facet_wrap(. ~ name, scales = "free", ncol = 4) +
    scale_x_continuous(breaks=scales::extended_breaks(n=3))
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}
```


```{r Take the last donations}
tic()
# last_donations2 <- donations %>% 
#   group_by(donor) %>% 
#   slice_max(order_by=dateonly, n=1) %>%
#   ungroup()
last_donations2 <- donations %>%   # This is faster
  arrange(dateonly) %>%
  group_by(donor) %>% 
  slice_tail(n=1) %>%
  ungroup()
toc()
```

```{r Data sizes}
sprintf("eProgesa has %i donors\n", nrow(last_donations2))
sprintf("Dosages has %i donors\n", nrow(dosages))
sprintf("Scores has %i donors\n", nrow(scores))
sprintf("Finngen has %i donors\n", nrow(finngen))
sprintf("Intersection has %i donors\n", length(intersect(intersect(intersect(last_donations2$donor, dosages$donor), scores$donor), finngen$donor)))
```
Why is the number of eProgesa donors so low in the below figure? It seems that the set counts are
the sums of intersections that belong to the set. The plot does not show show all intersections, even
when explicitly requested.

```{r}
set <- list(eProgesa = last_donations2$donor, dosages=dosages$donor, scores=scores$donor, finngen=finngen$donor)
upset <- UpSetR::upset(UpSetR::fromList(set), order.by = "freq", 
                       set_size.show=TRUE,
                       empty.intersections = TRUE,
                       set_size.scale_max = 50000, # This doesn't help to explain where donors from eProgesa disappear
                       nintersects = NA   # Show all intersections. Does not work. Six seems to be the maximum
                       # number of intersections
                       )
upset
```

```{r Check with raw eProgesa data}
# The raw donor information is used to compute more precise age of individuals
source("~/FRCBS/Hb_predictor_container/src/new_preprocess.R", chdir = TRUE)  
# NOTE: The above overwrites descript
# Hence we resource that file
source("common.R")
raw_donors <- read_donors("~/proj/interval_prediction/data/FRC.DW_DONOR.dat")
nrow(raw_donors)
length(intersect(finngen$donor, raw_donors$KEY_DONOR))
```
So, preprocessing of eProgesa data doesn't anymore drop half of the finngen donors.

### Combine all datas

```{r Combine datas}
filename <- sprintf("%s/last_donations.rds", base)
last_donations <- last_donations2 %>% 
  inner_join(dosages, by="donor") %>%
  inner_join(scores) %>%
  inner_join(finngen)
saveRDS(last_donations, filename)
```

```{r Summary of last donations}
summary(last_donations)
```

### Define variables

```{r Define variables}
variables <- c("previous_Hb", 
               "days_to_previous_fb", "female", "age", "year", "warm_season", "hour",
               #"consecutive_deferrals",  "previous_Hb_def",  # These are too similar to other variables
               "recent_donations", "recent_deferrals", "nb_donat", 
               "weight", 
               "smoking", 
               #"bmi", 
               "snp_17_58358769", "snp_6_32617727", "snp_15_45095352", "snp_1_169549811",
               "prs_anemia", "prs_ferritin", "prs_hemoglobin")

```


```{r}
model_variables <- c("Hb_deferral", variables)
cat(sprintf("Model variables are %s\n", paste(model_variables, collapse=", ")))
old_n <- nrow(last_donations)
last_donations <- last_donations %>% drop_na({{model_variables}})
cat(sprintf("Dropping %i/%i rows due to NA in model variables\n", old_n - nrow(last_donations), old_n))
```

```{r}
summary(last_donations %>% mutate(across(starts_with("snp_"), as.factor)))
```

```{r Summary plots of last donations}
tmp2 <- last_donations %>% 
  select(where(is.numeric)) %>% 
  pivot_longer(cols = everything(), names_to = "Variable" ) %>% 
  inner_join(descript %>% mutate(Variable = str_replace_all(Variable, "`", "")), 
             by="Variable")
  
myorder <- c(descript$Pretty[str_starts(descript$Pretty, "SNP")], descript$Pretty[str_starts(descript$Pretty, "PRS")])

g2 <- tmp2 %>% 
  mutate(Pretty = fct_relevel(Pretty, myorder)) %>% 
  ggplot(aes(value)) + 
  geom_histogram() + 
  facet_wrap(. ~ Pretty, scales = "free", ncol = 4) +
  scale_y_continuous(breaks=scales::extended_breaks(n=3))
if (save_figs) {
  filename <- sprintf("%s/variable_summary.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g2
```

```{r Summaries of stratified data}
for (g in c("male", "pre_menopausal_female", "post_menopausal_female")) {
  cat(sprintf("\n*** Group %s ***\n\n", g))
  print(summary(last_donations %>% filter(group == {{g}}) %>% mutate(across(starts_with("snp_"), as.factor))))
}
```

```{r Contingency tables for deferral and RNF43}
helper <- function(g, df) {
  cat(sprintf("\n*** %s ***\n", g))
  if (g != "all")
    df <- df %>% filter(group==g)
  print(table(df %>% select(snp_17_58358769, Hb_deferral)))
}
walk(c("all", "male", "pre_menopausal_female", "post_menopausal_female"), helper, last_donations)
```

### Split the data to train, validate, and test sets

```{r}
train <- last_donations %>% filter(label == "train")
validate <- last_donations %>% filter(label == "validate")
test <- last_donations %>% filter(label == "test")
nrow(train)
nrow(validate)
nrow(test)
```

### Correlation between hemoglobin PRS and hemoglobin

```{r}
r2 <- summary(lm(prs_hemoglobin ~ Hb, data=train))$r.squared
#r2_text <- sprintf("%.2f", r2)
mylabel <- sprintf("R^2==%.2f", r2)
# Use parse=TRUE instead of bquote:
# https://github.com/tidyverse/ggplot2/issues/4644
last_donations %>% ggplot(aes(x=Hb, y=prs_hemoglobin)) + 
  geom_point() + geom_smooth() + labs(y="Hemoglobin PS") +
  annotate("text", x=100, y=1e-5, color="black", label=mylabel, fontface="bold", parse=TRUE)
```
Not a huge correlation.

### Split data into demographic groups and scale

```{r Scale data for logistic regressions}
data <- last_donations %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_male <- last_donations %>% 
  filter(group == "male") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_female <- last_donations %>% 
  filter(group != "male") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_pre_menopausal_female <- last_donations %>% 
  filter(group == "pre_menopausal_female") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_post_menopausal_female <- last_donations %>% 
  filter(group == "post_menopausal_female") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
  
```

## Total genetic risk


```{r}
total <- dosages %>% rowwise(donor) %>% summarise(total=sum(c_across(everything())))
g <- total %>% ggplot(aes(x=total)) + geom_bar() 
g + labs(x="Total dosage")
```



## Logistic regression


```{r Frequentist logistic regression formula}
my_formula <- as.formula(sprintf("Hb_deferral ~ %s", paste(variables, collapse=" + ")))
print(my_formula)
```


```{r Detect for separation, eval=FALSE}
# 'safeBinaryRegression' package sucks, I now use 'detectseparation' instead!
fit <- stats::glm(my_formula,
#fit <- safeBinaryRegression::glm(my_formula,
             #data = tmp, # For safeBinaryRegression
             data = data,
             method="detect_separation",
             family = "binomial")
fit
```

No separation detected. Lets fit the model.

```{r}
filename <- sprintf("%s/fit.rds", base)
if (recompute | !file.exists(filename)) {
  fit <- stats::glm(my_formula,
             data = data,
             family = binomial)
  saveRDS(fit, filename)
} else {
  fit <- readRDS(filename)
}
```

If safeBinaryRegression was used, it complained that all variables were causing separation among the sample points.
I disabled the package.

```{r}
summary(fit)
```

Why is the effect of 'female' variable negative? Positive effect would be expected! BECAUSE MALES AND FEMALE HAVE DIFFERENT HB LEVELS AND HB_THRESHOLDS!!!

```{r}
table(data %>% select(female, Hb_deferral))  # This looks as expected
myvariables <- unique(c("female", variables)) # Move female to front of the list
# Add one variable at time to model and fit it
test_df <- tibble(variables = map(1:length(myvariables), function(i) myvariables[1:i]),
                  added_variable = map_chr(variables, function(v) tail(v, n=1)),
                  formula = map(variables, 
                                function(v) as.formula(sprintf("Hb_deferral ~ %s", paste(v, collapse=" + ")))),
                  fit = map(formula, function(f) stats::glm(f, data=data, family=binomial))
                  )
test_df
test_result <- pmap_dfr(test_df, function(variables, added_variable, formula, fit) {
  broom::tidy(fit) %>% mutate(added_variable=factor(added_variable, levels = myvariables))
})

# In the plot variables are added to the model starting from the top
test_result %>% filter(term == "femaleTRUE") %>% 
  ggplot(aes(x=estimate, y = fct_rev(added_variable))) +
  geom_point()
```

Let's see if interaction help with this.

```{r}
int_fit <- stats::glm(Hb_deferral ~ female + previous_Hb + female:previous_Hb, data=data, family=binomial)
# Compare with the model with female predictor
test_df %>% pluck("fit", 1)
# Compare with the model without interaction
test_df %>% pluck("fit", 2)
# With interactions
int_fit
```

Well, actually this is expect as males and females have different hb levels and hb thresholds.

### Diagnostics

#### Residual deviance

Residual deviance is significantly smaller than null deviance so the predictors offer significant information.
The median of deviance residuals is not very close to zero, which means there could be a small bias. The distribution of residuals should
be approximately normal: [What do the residuals in a logistic regression mean](https://stats.stackexchange.com/questions/1432/what-do-the-residuals-in-a-logistic-regression-mean)

```{r Plot the deviance residuals}
last_donations %>% drop_na() %>% mutate(residual=residuals(fit)) %>% ggplot(aes(x=residual)) + geom_histogram()
```


For explanation of deviance see:

* [Interpreting Residual and Null Deviance in GLM R](https://stats.stackexchange.com/questions/108995/interpreting-residual-and-null-deviance-in-glm-r)
* [Interpreting Generalized Linear Models](https://www.datascienceblog.net/post/machine-learning/interpreting_generalized_linear_models/)

```{r Pretty logistic formula}
# This is for presentation purposes
s <- as.character(formula(fit))
conv <- setNames(descript$Pretty, descript$Variable)
conv <- conv[conv != "Hemoglobin"]
cat(sprintf("Hb deferral ~ %s", str_replace_all(s[[3]], conv)))
```

#### Default glm diagnostics

```{r Diagnostic plots for linear model}
plot(fit, which=c(1,2,3,4,5))
```
One should not use the above plots to interpret results of logistic regression according to 
https://stats.stackexchange.com/questions/234998/logistic-regression-diagnostic-plots-in-r

The advise on page http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/
is to check for

* linearity
* influential points using Cook's distance (above plot showed no influential points)
* multicollinearity using Variance inflation factors


#### Check for linearity

```{r}
probabilities <- predict(fit, type = "response")
```

```{r}
#variables <- str_split(as.character(formula(fit))[[3]], " \\+ ")[[1]]
#variables <- str_subset(variables, "`", negate=TRUE)
data2 <- data %>% 
  drop_na() %>% 
  select(all_of(variables)) %>% 
  select(where(is_double)) %>% 
  mutate(logit=log(probabilities/(1-probabilities)))
```

```{r Relation between each predictor with the logit scale response}
filename <- sprintf("%s/linearity_check.png", fig_path)
if (recompute_linearity_check | !file.exists(filename)) {
  g <- data2 %>%
    #slice_sample(n=1000) %>% # For quick testing purposes
    #mutate(across(c(consecutive_deferrals, recent_deferrals), function(x) log(x))) %>%
    pivot_longer(cols = -logit, names_to = "predictor") %>%
    ggplot(aes(logit, value))+
    geom_point(size = 0.5, alpha = 0.5) +
    geom_smooth(method = "loess") + 
    theme_bw() + 
    facet_wrap(~predictor, scales = "free_y")
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}

```

All variables except maybe consecutive_deferrals and recent_deferrals seem to be linearly related to the logit scale response.

#### Check for multicollinearity

```{r Check for multicollinearity}
sort(car::vif(fit), decreasing = TRUE)
```
According to https://www.statisticshowto.com/variance-inflation-factor/
VIF value greater than 5 means that it is highly correlated with other predictors.
So, it seems that weight and bmi are correlated, of course. And probably consecutive_deferrals and previous_Hb_def.

The below figure is slow to compute.

```{r Correlations between variables, eval=FALSE}
# Function to return points and geom_smooth
# allow for the method to be changed
my_fn <- function(data, mapping, method="loess", ...){
      p <- ggplot(data = data, mapping = mapping) + 
      geom_point() + 
      geom_smooth(method=method, ...)
      p
    }
g <- ggpairs(data2 %>% select(-logit), lower = list(continuous = my_fn))
if (save_figs) {
  filename <- sprintf("%s/correlations.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
```


### Effect sizes

The profiling method of MASS and my simple approximation seem to produce same results.
Next, check if bootstrapping would change this.

```{r Coefficients and confidence intervals}
self_made_cis <- function(fit) {
  c3 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c <- c3 %>% 
    mutate(low = Estimate - 1.96*`Std. Error`, 
           high = Estimate + 1.96*`Std. Error`) 
  return(c)
}
mass_cis <- function(fit) {   # This uses profiling based method from MASS
  c3 <- rownames_to_column(as.data.frame(confint(fit)), var="Variable") %>% as_tibble()
  c4 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c3 <- c3 %>% inner_join(c4, by="Variable")
  c <- c3 %>% 
    rename(low = `2.5 %`, high = `97.5 %`)
  return(c)
  
}

descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))
freq_cis <- bind_rows("Self-made" = self_made_cis(fit), "MASS" = mass_cis(fit), .id="Method") %>%
  left_join(descript2, by=c(Variable="Variable2")) %>%
  filter(Variable != "(Intercept)") %>%
  mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
  mutate(Pretty = as.factor(Pretty)) %>%
  mutate(across(c(Estimate, low, high), exp))

freq_cis %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Method)) +
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_pointrange(position=position_dodge(width=1)) + 
  labs(title="Frequentist", x="Odds ratio", y="Standardized variables") + 
  scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/normalised_effect_sizes.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}

```


## Bayesian logistic regression



```{r}
iterations <- 1000
cores <- 4
bayesian_variables <- setdiff(variables, "female")
bayes_formula <- as.formula(sprintf("Hb_deferral ~ %s", paste(bayesian_variables, collapse=" + ")))
print(bayes_formula)
bayes_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", paste(variables, collapse=" + ")))
print(bayes_formula_all)
datas <-list(all=data, male=data_male, female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
bayesian_formulas <- list(all=bayes_formula_all, male=bayes_formula, female=bayes_formula,
             pre_menopausal_female=bayes_formula,
             post_menopausal_female=bayes_formula)
```

Flat prior is used for every parameter except the Intercept and sigma are student_t distributed.

```{r Show the used priors, eval=FALSE}
get_prior(bayes_formula, data_male)
```



```{r Fit all Bayesian models}
fit_bayesian_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_fit_%s.rds", base, group)
  if (recompute | !file.exists(filename)) {
    bayesian_fit <- brm(formula,
                            data = data, 
                            family = bernoulli(),
                            file = NULL,
                            control = list(max_treedepth = 15),
                            refresh = 0,
                            cores = cores,
                            iter = iterations
    )
    saveRDS(bayesian_fit, filename)
  } else {
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
#summary(bayesian_fit_all)
bayesian_input <- tibble(group=names(cohort_colors),
                         data=datas,
                         formula=bayesian_formulas)
bayesian_fits <- pmap_dfr(bayesian_input, fit_bayesian_helper)
bayesian_fits_list <- deframe(bayesian_fits)
```



### Diagnostics

#### Trace
```{r}
#mcmc_plot(bayesian_fit, type = "trace", n_warmup = 500)
# Include the warmup iterations for comparison
# bayesian_fits <- tibble(id=c("all", "male", "pre_menopausal_female", "post_menopausal_female"),
#                         fit=list(bayesian_fit_all, bayesian_fit_male, bayesian_fit_pre_menopausal_female, bayesian_fit_post_menopausal_female))
helper <- function(group, fit) {
  bp <- bayesplot::mcmc_trace(as_draws_array(fit, inc_warmup = TRUE), n_warmup = iterations/2)
  if (save_figs) {
    filename <- sprintf("%s/traces_%s.png", fig_path, group)
    ggsave(filename=filename,  plot=bp, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  bp
}
#walk2(bayesian_fits$id, bayesian_fits$fit, helper)
pmap(bayesian_fits, helper)
```

#### Auto-correlation

Is there something wrong with this? No, one just needs to zoom it!

```{r}
#mcmc_plot(bayesian_fit, type = "acf_bar")
#map(deframe(bayesian_fits), mcmc_plot, type = "acf_bar")
pmap(bayesian_fits, ~ mcmc_plot(.y, type = "acf_bar") + labs(title=.x))

```

Check Rhats to see if we converged.

```{r}
helper <- function(group, fit) {
  mcmc_plot(fit, type = "rhat") + labs(title=group)
}
#map2(bayesian_fits$id, bayesian_fits$fit, helper) # These are all equivalent, but the last one is the shortest
#pmap(bayesian_fits, helper)
pmap(bayesian_fits, ~ mcmc_plot(.y, type = "rhat") + labs(title=.x))
```

We reached convergence.

#### Effect distributions

```{r , message=FALSE, warning=FALSE}
variables2 <- descript2 %>% 
  filter(Variable %in% bayesian_variables) %>%
  arrange(Pretty) %>% pull(Variable2) %>% unique %>% rev
bvariables <- if_else(variables2 != "(Intercept)", sprintf("b_%s", variables2), "b_Intercept")
forest_plot <- function(fit, id) {
  p <- mcmc_plot(fit, 
                 type = "areas",
                 prob = 0.95,        # This is the width of the light blue shaded area ("inner"). 
                 prob_outer = 1.0,   # This is the width of the outline ("outer")
                 # The dark blue comes from the "point" estimate but I don't know how to turn it off.
                 variable = bvariables,
                 area_method = "equal area",
                 transformations = "exp"
  ) +
    geom_vline(xintercept = 1, color = "grey") +
    labs(x="Odds ratio") + 
    scale_x_log10()
  if (save_figs) {
    filename <- sprintf("%s/bayesian_area_plots_%s.png", fig_path, id)
    ggsave(filename=filename,  plot=p, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  p
}

# This self-made version has pretty labels unlike the previous function
forest_plot2 <- function(fit, id) {
  a <- as.array(fit, variable=bvariables)
  tmp <- mcmc_areas_data(a, 
                         prob = 0.95,
                         area_method = "equal area",
                         #variable = variables2,
                         transformations = "exp"
  )
  
  tmp2 <- tmp %>% 
    filter(parameter != "exp(b_intercept)") %>% 
    mutate(parameter = str_match(parameter, "exp\\(b_(.*)\\)")[,2]) %>%
    inner_join(descript2, by=c(parameter = "Variable2")) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Pretty = fct_rev(Pretty))
  
  g2 <- tmp2 %>% 
    filter(interval == "inner") %>% 
    ggplot(aes(x=x, y=Pretty, height=plotting_density)) + 
    geom_ridgeline(scale=0.9) +  # Shaded area ("inner")
    geom_ridgeline(mapping=aes(x=x, y=Pretty, height=plotting_density), # The black outline ("outer")
                   data=tmp2 %>% filter(interval=="outer"), 
                   fill=NA, scale=0.9) +
    scale_y_discrete() +
    labs(x="Odds ratio", y="Variable") +
    scale_x_log10()
}

```

```{r}
g <- forest_plot2(bayesian_fits_list$all, "all")
g
```


```{r}
g <- forest_plot2(bayesian_fits_list$male, "male")
g
```

```{r}
g <- forest_plot2(bayesian_fits_list$female, "female")
g
```


```{r}
g <- forest_plot2(bayesian_fits_list$pre_menopausal_female, "pre_menopausal_female")
g
```

```{r}
g <- forest_plot2(bayesian_fits_list$post_menopausal_female, "post_menopausal_female")
g
```

### Effect sizes

```{r}
get_bayes_intervals <- function(bayesian_fit) {
  bayes_cis <- mcmc_intervals_data(as_draws_array(bayesian_fit), 
                                   point_est="mean", regex_pars = "^b_.*", prob = 0, prob_outer = 0.95)
  bayes_cis <- bayes_cis %>% 
    rename(Variable=parameter, Estimate=m, low=ll, high=hh) %>%
    mutate(Variable = str_remove(Variable, "b_")) %>%
    mutate(Variable = if_else(Variable=="Intercept", "(Intercept)", Variable)) %>%
    select(Variable, low, Estimate, high)
  return(bayes_cis)
}
```

```{r}
filename <- sprintf("%s/bayes_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  bayes_cis <- map_dfr(bayesian_fits_list, get_bayes_intervals, .id="Group") %>%
    left_join(descript2, by=c(Variable = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    filter(Variable != "(Intercept)") %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    mutate(across(c(Estimate, low, high), exp))
  write_tsv(bayes_cis, file=filename)
} else {
  bayes_cis <- read_tsv(filename)
}
```

```{r}
```

```{r Compare confidence intervals of Bayesian method on three strata}
g <- bayes_cis %>% 
  mutate(across(c(Group, Pretty), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(bayes_cis, Pretty) +
  # geom_rect(data=make_stripes(bayes_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) + 
  labs(title = "Bayesian", x="Odds ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10() +
  scale_y_discrete()  # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale

if (save_figs) {
  filename <- sprintf("%s/bayes_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

## Combine confidence intervals from three methods on full data.


```{r Compare confidence intervals of coefficients from two frequentist and one Bayesian method}
d <- bind_rows(freq_cis, bayes_cis %>% mutate(Method="Bayes") %>% filter(Group=="male")) %>%
  mutate(Method = ifelse(Method=="Self-made", "Normal", Method))
#  mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty))
g <- d %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Method)) + 
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Odds ratio", y="Standardized variables") 
g <- g + scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/cis_from_three_methods.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

## Odds ratios of high genetic risk versus low genetic risk

```{r, results='asis'}
genetic_variables <- c("prs_anemia", "prs_ferritin", "prs_hemoglobin", "snp_1_169549811", "snp_6_32617727", 
                       "snp_15_45095352", "snp_17_58358769")
compute_total_score <- function(group, data, effect_sizes) {
  v <- effect_sizes %>% 
    filter(Group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
    select(Variable, Estimate) %>% 
    mutate(Estimate = log(Estimate)) %>%
    deframe()
  #total <- dosages %>% rowwise(donor) %>% summarise(total=sum(c_across(everything())))
  weighted_sum <- data %>% mutate(total = 
                                              prs_anemia * v[["prs_anemia"]] +
                                              prs_ferritin * v[["prs_ferritin"]] +
                                              prs_hemoglobin * v[["prs_hemoglobin"]] +
                                              snp_1_169549811 * v[["snp_1_169549811"]] + 
                                              snp_6_32617727  * v[["snp_6_32617727"]]  +
                                              snp_15_45095352 * v[["snp_15_45095352"]] +
                                              snp_17_58358769 * v[["snp_17_58358769"]])
  weighted_sum
}
# Returns the lower limit for odds ratio of high genetic risk versus low genetic risk
get_odds_ratio <- function(group, limits=c(0.1, 0.9)) {
  if (length(limits) == 1)
    limits <- sort(c(limits, 1-limits))
  else stopifnot(length(limits==2) && sum(limits) == 1)
  #print(limits)
  weighted_sum <- compute_total_score(group, datas[[group]], bayes_cis)
  qs <- quantile(weighted_sum$total, limits)
  odds_ratio <- exp(qs[[2]]) / exp(qs[[1]])
  odds_ratio
}
cat(sprintf("Lower limit for odds ratio for males: %f\n", get_odds_ratio("male")))
cat(sprintf("Lower limit for odds ratio for premenopausal females: %f\n", get_odds_ratio("pre_menopausal_female")))
cat(sprintf("Lower limit for odds ratio for postmenopausal females: %f\n", get_odds_ratio("post_menopausal_female")))
# g2 <- weighted_sum %>% ggplot(aes(x=plogis(total))) + geom_histogram() 
# g2 + labs(x="Deferral probability")

# Show the variant dosage combinations of the people in the top 10% of the genetic risk
# for (group in c("male", "pre_menopausal_female", "post_menopausal_female")) {
#   cat(sprintf("*** %s ***\n", group))
#   df <- compute_total_score(group)
#   g <- df %>% ggplot(aes(x=total)) + geom_histogram() 
#   g <- g + labs(x="Total genetic score", title=group)
#   plot(g)
#   df <- df %>% 
#     filter(total >= quantile(df$total, 0.90)) %>% 
#     group_by(across(starts_with("snp_"))) %>% 
#     summarise(average_total=mean(total), n=n(), .groups="drop") %>% 
#     arrange(average_total) #%>% 
#   #rename(average_total=total)
#   #print(df)
#   print(knitr::kable(df))
# }
```

Average predictor values in each percentile.

```{r, eval=FALSE}
for (group in c("male", "pre_menopausal_female", "post_menopausal_female")) {
  df <- compute_total_score(group, datas[[group]], bayes_cis)
  # Compute the percentile to which each donor belongs to
  df2 <- df %>% 
    mutate(percentile = cut(total, 
                            breaks=quantile(total, seq(0.0, 1.0, 0.1)), 
                            labels=1:10,
                            include.lowest=TRUE)) 
    my_summarise <- function(df, func) {
      df %>%
        group_by(percentile) %>%
        summarise(across(all_of(genetic_variables), func)) %>%
        pivot_longer(cols = !percentile)
    }
    L <- list(mean=my_summarise(df2, mean), median=my_summarise(df2, median))
    g <-  bind_rows(L, .id="Method") %>%
      ggplot(aes(x=percentile, y=value, fill=name)) +
      geom_col(position="dodge") +
      GGally::geom_stripped_cols() +
      facet_grid(~Method) +
      labs(title=group) +
      theme(#legend.position="bottom",    
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
    plot(g)
  
}
```

Weighted average predictor values in each risk score percentile. Weight each variable by its effect size.

```{r}
risk_score_histogram <- function(group, data, effect_sizes)  {
  # Effect sizes of genetic variables
  v <- effect_sizes %>% 
    filter(Group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
    select(Variable, Estimate) %>% 
    mutate(Estimate = log(Estimate)) %>%
    deframe()
  df <- compute_total_score(group, data, effect_sizes)
  # Compute the percentile to which each donor belongs to
  df2 <- df %>% 
    mutate(percentile = cut(total, 
                            breaks=quantile(total, seq(0.0, 1.0, 0.1)), 
                            labels=1:10,
                            include.lowest=TRUE)) %>%
    mutate(across(all_of(genetic_variables), function(x) x*v[[cur_column()]]))
           # prs_anemia      = prs_anemia * v[["prs_anemia"]],
           # prs_ferritin    = prs_ferritin * v[["prs_ferritin"]],
           # prs_hemoglobin  = prs_hemoglobin * v[["prs_hemoglobin"]],
           # snp_1_169549811 = snp_1_169549811 * v[["snp_1_169549811"]], 
           # snp_6_32617727  = snp_6_32617727  * v[["snp_6_32617727"]],
           # snp_15_45095352 = snp_15_45095352 * v[["snp_15_45095352"]],
           # snp_17_58358769 = snp_17_58358769 * v[["snp_17_58358769"]]) 
    my_summarise <- function(df, func) {
      df %>%
        group_by(percentile) %>%
        summarise(across(all_of(genetic_variables), func)) %>%
        pivot_longer(cols = !percentile)
    }
    L <- list(mean=my_summarise(df2, mean), median=my_summarise(df2, median))
    df <- bind_rows(L, .id="Method") %>%
      mutate(name = factor(name, levels=genetic_variables))
    df
}
visualize_risk_score_histogram <- function(df) {
    g <- df %>%
      ggplot(aes(x=percentile, y=value, fill=name)) +
      geom_col(position="stack") +
      GGally::geom_stripped_cols() +
      facet_grid(~Method) +
      labs(title=group) +
      theme(#legend.position="bottom",    
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
    g
}
groups <- c("male", "female", "pre_menopausal_female", "post_menopausal_female")
bayes_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, datas[[group]], bayes_cis))
names(bayes_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(bayes_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_bayes_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```



### Confidence intervals

```{r}
# Returns an array of total genetic scores with rows as sampling iterations (4*500) and columns as individuals
sample_sum_scores <- function(group) {
  draws <- as_draws_array(bayesian_fits_list[[group]])
  d <- dim(draws)
  n <- d[[1]] * d[[2]]   # iterations * chains
  betas <- posterior::subset_draws(draws, 
                        variable = str_replace(genetic_variables, "^", "b_"), 
                        draw = 1:n)
  betas <- drop(unclass(betas))  # Drop redundant singleton dimension of chains, since the are merged to a single chain
  # Remove "b_" from the start of variable names
  tmp <- dimnames(betas)
  tmp$variable <- str_remove(tmp$variable, "^b_")
  dimnames(betas) <- tmp
  #betas %>% skimr::skim() %>% focus(numeric.mean, numeric.sd) %>% as_tibble() %>% print()
  covariates <- t(datas[[group]] %>% select(all_of(genetic_variables)))
  # print(attributes(betas))
  # print(attributes(covariates))
  # Check that the variable names are in same order
  stopifnot(dimnames(betas)[[2]] == dimnames(covariates)[[1]])
  weighted_sum <- betas %*% covariates
  names(dimnames(weighted_sum)) <- c("iteration", "individual")
  weighted_sum
}
# Returns an array of total genetic scores with rows as sampling iterations and columns as individuals.
# This version samples from a normal distribution.
sample_sum_scores2 <- function(group, data, effect_sizes, iterations=2000) {
  get_samples <- function(Variable, low, Estimate, high) {
    #print(c(Variable, low, Estimate, high))
    mysd <- (high-Estimate)/qnorm(0.975)   # Standard deviation
    v <- rnorm(iterations, mean=Estimate, sd=mysd)
    #print(v)
    df <- tibble({{Variable}}:=v)
    #print(df)
    return(df)
  }
  effect_sizes <- effect_sizes %>% 
    filter(Group == group, Variable %in% genetic_variables) %>%
    select(Variable, low, Estimate, high) %>%
    mutate(across(c(low, Estimate, high), log))  # Back to linear scale
  # 'iterations' rows and column for each variable
  # For some reason the pmap_dfc call didn't work
  betas <- bind_cols(pmap(effect_sizes, get_samples)) %>% 
    select(genetic_variables) %>%  # Reorder the variables
    data.matrix()                  # Convert to matrix
  #betas %>% skimr::skim() %>% skimr::focus(numeric.mean, numeric.sd) %>% as_tibble() %>% print()
  #pmap_dfc(effect_sizes, get_samples)
  covariates <- t(data %>% select(all_of(genetic_variables)))
  dimnames(betas)[[1]] <- as.character(1:iterations)
  #print(attributes(betas))
  #print(attributes(covariates))
  # Check that the variable names are in same order
  #print(dimnames(betas)[[2]])
  #print(dimnames(covariates)[[1]])
  stopifnot(dimnames(betas)[[2]] == dimnames(covariates)[[1]])
  weighted_sum <- betas %*% covariates
  #print(attributes(weighted_sum))
  names(dimnames(weighted_sum)) <- c("iteration", "individual")
  weighted_sum
}

```

```{r}
get_odds_ratio2 <- function(weighted_sum, limits=c(0.1, 0.9)) {
  if (length(limits) == 1)
    limits <- sort(c(limits, 1-limits))
  else stopifnot(length(limits==2) && sum(limits) == 1)
  qs <- quantile(weighted_sum, limits)
  odds_ratio <- exp(qs[[2]]) / exp(qs[[1]])
  odds_ratio
}
filename <- sprintf("%s/deferral_bayes_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- names(bayesian_fits_list)[2:5]
  group_names
  weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  #weighted_sum_samples <- map2(group_names, datas[group_names], sample_sum_scores2, bayes_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  bayes_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  bayes_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(bayes_genetic_risks, file=filename)
} else {
  bayes_genetic_risks <- read_tsv(filename)
}
bayes_genetic_risks
```


# Survival analysis

```{r}
helper <- function(df, key) {
  df2 <- df %>% filter(Hb_deferral)
  if (nrow(df2) > 0) {
    return(tibble(status=1, dateonly=first(df2$dateonly), age_at_first_attempt = min(df$age)))
  } else {
    return(tibble(status=0, dateonly=last(df$dateonly), age_at_first_attempt = min(df$age)))   # censored
  }
}
survival_filename <- sprintf("%s/survival.rds", base)
if (recompute_survival | !file.exists(survival_filename)) {
  #library(multidplyr)  # Does not support group_modify
  #cluster <- new_cluster(4)
  sur3 <- donations %>%
    #filter(label == "train") %>%
    arrange(dateonly) %>%
    group_by(donor) %>%
    #partition(cluster) %>%
    group_modify(helper) %>%
    ungroup()
    #collect()
  saveRDS(sur3, survival_filename)
} else {
  sur3 <- readRDS(survival_filename) %>% ungroup()
}
```

```{r}
head(sur3 %>% select(-donor))
```


```{r}
# Compute age with more precision
get_dob <- function() {
  res <- raw_donors %>% select(donor=KEY_DONOR, dob=KEY_DONOR_DOB) %>% mutate(dob=lubridate::ymd(dob))
  return(res)
}
add_age <- function(df) {
  df <- inner_join(df, get_dob()) %>%
    mutate(age = as.numeric((dateonly - dob) / 365.25))
}
filename <- sprintf("%s/full_survival_data.rds", base)
if (recompute | !file.exists(filename)) {
  sur <- donations %>% 
    inner_join(sur3, by=c("donor", "dateonly")) %>%
    inner_join(finngen, by="donor") %>%
    inner_join(dosages, by="donor") %>%
    inner_join(scores, by="donor") %>%
    mutate(across(where(is.logical), as.factor))
  
  sur <- add_age(sur)
  
  saveRDS(sur, filename)
} else {
  sur <- readRDS(filename)
}
```

```{r}
sprintf("%i donors, %i events, %i censored", nrow(sur), sum(sur$status == 1), sum(sur$status == 0))
cat(sprintf("Prevalence of Hb-deferral: %.1f", 100*sum(sur$status == 1) / nrow(sur)))
```




```{r}
s <- survival::Surv(sur$age, sur$status)
head(s)
```

```{r}
unscaled_sur_male <- sur %>% filter(group == "male")
unscaled_sur_female <- sur %>% filter(group != "male")
unscaled_sur_pre_menopausal_female <- sur %>% filter(group == "pre_menopausal_female")
unscaled_sur_post_menopausal_female <- sur %>% filter(group == "post_menopausal_female")
```

```{r Scale for Cox models}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("age", "status")) & ! starts_with("snp_"), myscale))
}
scaled_sur <- scale_helper(sur)
scaled_sur_male   <- scale_helper(unscaled_sur_male)
scaled_sur_female   <- scale_helper(unscaled_sur_female)
scaled_sur_pre_menopausal_female  <- scale_helper(unscaled_sur_pre_menopausal_female)
scaled_sur_post_menopausal_female <- scale_helper(unscaled_sur_post_menopausal_female)
```

Check the male data. Because the data is sorted by time, some distributions look very skewed.

```{r}
tmp <- scaled_sur_male %>% 
  select(-c(recent_deferrals, consecutive_deferrals)) %>%
  drop_na() %>% 
  mutate(smoking=as.numeric(smoking)) %>% 
  select(where(is.numeric)) %>%
  mutate(donors = ifelse(row_number() <= 1700, "old", "new")) %>%
  group_by(donors) %>% slice_sample(n=1700) %>% ungroup()

tmp %>%
#  pivot_longer(cols = everything()) %>% 
  pivot_longer(cols = -donors) %>% 
  ggplot(aes(x=value, fill=donors)) + geom_histogram(position = "dodge") + 
  facet_wrap(~name, scales = "free")
```


## Kaplan-Meier curve

```{r}
km_fit <- survival::survfit(Surv(age, status) ~ 1, data=sur)
autoplot(km_fit) + labs(x="Age", y="Survival from Hb deferral")
ggsurvplot(km_fit, palette = "#2E9FDF", conf.int = TRUE, risk.table = TRUE, risk.table.y.text.col=TRUE)
```

```{r Stratify by sex}
ggsurvplot(survival::survfit(Surv(age, status) ~ female, data=sur), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip male}
helper <- function(fun) {
  g <- ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_male), 
             fun=fun, conf.int = TRUE) 
             #risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
  g
}
g1 <- helper("event")
g2 <- helper(NULL)  # no transformation means the normal survival curve
g3 <- helper("cumhaz")
arrange_ggsurvplots(list(g1, g2, g3), ncol=1, nrow=3)
#print(g1$plot)
#print(g2$plot)
#print(g3$plot)
```


```{r Stratify by RNF43 snip female}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```


```{r Stratify by RNF43 snip premenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_pre_menopausal_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip postmenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, 
                             # There is only one homozygote with this snip
                             data=unscaled_sur_post_menopausal_female %>% filter(snp_17_58358769 != 2)), 
           conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

## Cox regression

```{r Define formulas}
cox_variables <- c("weight", 
                   #"bmi", 
                    "previous_Hb",
                   "smoking", 
                   "snp_17_58358769", "snp_6_32617727",  "snp_15_45095352", "snp_1_169549811", 
                   "prs_anemia", "prs_ferritin", "prs_hemoglobin", "donation_count" )
cox_formula <- as.formula(sprintf("Surv(age, status) ~ %s", paste(cox_variables, collapse=" + ")))
cox_formula_all <- as.formula(sprintf("Surv(age, status) ~ %s", paste(c(cox_variables, "female"), collapse=" + ")))
print(cox_formula)
print(cox_formula_all)
```

### Fit models

```{r Fit Cox models}
cox_fit_all    <- survival::coxph(cox_formula_all, data=scaled_sur)
cox_fit_male   <- survival::coxph(cox_formula,     data=scaled_sur_male)
cox_fit_female <- survival::coxph(cox_formula,     data=scaled_sur_female)
cox_fit_pre_menopausal_female  <- survival::coxph(cox_formula, data=scaled_sur_pre_menopausal_female)
cox_fit_post_menopausal_female <- survival::coxph(cox_formula, data=scaled_sur_post_menopausal_female)
cox_fit_list <- list(all=cox_fit_all, male=cox_fit_male, female=cox_fit_female,
                     pre_menopausal_female=cox_fit_pre_menopausal_female,
                     post_menopausal_female=cox_fit_post_menopausal_female)

```


```{r}
g <- survminer::ggsurvplot(survfit(cox_fit_male), scaled_sur_male, risk.table = TRUE)
g
```

Below, on the left are the Kaplan-Meier curves and on the right the Cox proportional hazards model. For each model the event, survival and cumulative hazard curves are shown. This is for male data. Effect of snp_17_58358769
is illustrated. On the right, the model forces the proportional hazard assumption to hold.

```{r}
# Keep other variables at zero and vary the variable snp_17_58358769
row1 <- as_tibble_row(set_names(rep(0, length(cox_variables)), cox_variables))
params <- bind_rows(row1, row1 %>% mutate(snp_17_58358769=1)) %>% 
  mutate(smoking = as.factor(smoking==1))
params
helper <- function(fun) {
  #survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), scaled_sur_male, risk.table = TRUE)
  sf <- survfit(cox_fit_male, data=scaled_sur_male)
  df <- as.data.frame(params)
  g <- survminer::ggsurvplot(survfit(cox_fit_male, newdata=df), 
                             data=df, risk.table = FALSE, fun=fun)
  g
}
g4 <- helper("event")
g5 <- helper(NULL)
g6 <- helper("cumhaz")
g <- arrange_ggsurvplots(list(g1, g2, g3, g4, g5, g6), 
                         title="Effect of SNP 17:58358769",
                         ncol=2, nrow=3)
g
```



```{r All survival, eval=FALSE}
# g <- survminer::ggforest(cox_fit_all, data = scaled_sur) 
# g
```

```{r Male survival}
# g <- survminer::ggforest(cox_fit_male, data = scaled_sur_male) 
# g
```

```{r Female survival}
# g <- survminer::ggforest(cox_fit_female, data = scaled_sur_female) 
# g
```

```{r Premenopausal female survival}
# survminer::ggforest(cox_fit_pre_menopausal_female, data = scaled_sur_pre_menopausal_female) 
```

```{r Postmenopausal female survival}
#survminer::ggforest(cox_fit_post_menopausal_female, data = scaled_sur_post_menopausal_female) 
```

### Effect sizes

```{r}
descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))

filename <- sprintf("%s/cox_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  cox_cis <- bind_rows(map(cox_fit_list, mass_cis), .id="Group") %>%
    rename(Estimate=coef) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    left_join(descript2, 
              by=c(Variable="Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    #mutate(Pretty = fct_relevel(as.factor(Pretty), myorder)) %>%
    mutate(across(c(Estimate, low, high), exp))
  write_tsv(cox_cis, file=filename)
} else {
  cox_cis <- read_tsv(filename)
}
```

```{r}

mylimits <- c(0.2, 4)
g <- cox_cis %>% 
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(cox_cis, Pretty) +
  # geom_rect(data=make_stripes(cox_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") + 
  #xlim(0.2, 10) +
  scale_x_log10(limits=mylimits) +
  scale_y_discrete() + 
  scale_colour_manual(values=cohort_colors) +
  labs(title="Cox model")
if (save_figs) {
  filename <- sprintf("%s/cox_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Odds ratios of high genetic risk (normal Cox)

```{r}
normal_cox_datas <- list(male=scaled_sur_male, female=scaled_sur_female)
groups <- c("male", "female")
normal_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, normal_cox_datas[[group]], cox_cis))
names(normal_cox_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(normal_cox_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_normal_cox_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r}
filename <- sprintf("%s/deferral_normal_cox_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- c("male", "female")
  group_names
  #weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  weighted_sum_samples <- map2(group_names, normal_cox_datas[group_names], sample_sum_scores2, cox_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  normal_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  normal_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(normal_cox_genetic_risks, file=filename)
} else {
  normal_cox_genetic_risks <- read_tsv(filename)
}
normal_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cox male)}
genetic_scores <-  compute_total_score("male", scaled_sur_male, cox_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
#sf <- survfit(cox_fit_male, data=scaled_sur_male)
g <- survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cos female)}
genetic_scores <-  compute_total_score("female", scaled_sur_female, cox_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
sf <- survfit(cox_fit_female, data=scaled_sur_female)
g <- survminer::ggsurvplot(survfit(cox_fit_female, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```


### Diagnostics

See [diagnostics](http://www.sthda.com/english/wiki/cox-model-assumptions)

#### Check for proportional hazards assumption

Test the null hypothesis that the proportional hazards assumption holds.


```{r}
extract_ph_stats <- function(fit) { # Get p-values of variables from the fit
  survival::cox.zph(fit)$table %>% as.data.frame() %>% rownames_to_column(var="variable") %>% select(variable, p)
}
res <- map_dfr(cox_fit_list, extract_ph_stats, .id="model") %>% pivot_wider(names_from = model, values_from=p)
pvalue_table(res)
#res
```

No surprise that the proportional hazards assumption does not seem to hold for donation_count as it is time-dependent variable.

Why are some plots below bipartite or tripartite? Categorical covariates can cause this. See for example
https://mwsug.org/proceedings/2006/stats/MWSUG-2006-SD08.pdf

```{r, eval=FALSE}
# Don't repeat the constant part of labels
helper <- function(g) {
  g$labels$title <- str_remove(g$labels$title, "Schoenfeld Individual ")
  g$labels$y <- str_remove(g$labels$y, "Beta\\(t\\) for ")
  g
}
schoenfeld_residuals <- function(fit, title) {
  test_ph <- cox.zph(fit)
  g <- ggcoxzph(test_ph)
  g <- map(g, helper)   # Remove the repeated texts
  # I use plot_grid instead of the default plotting method, since
  # otherwise the combined plot disappears, when zoomed.
  g2 <- cowplot::plot_grid(plotlist = g)
  annotate_figure(g2, top = text_grob(paste("Schoenfeld residuals", title, sep=" ")),
                  left = "Beta(t)")
}
schoenfeld_residuals(cox_fit_all, "all")
schoenfeld_residuals(cox_fit_male, "male")
schoenfeld_residuals(cox_fit_female, "female")
schoenfeld_residuals(cox_fit_pre_menopausal_female, "premenopausal female")
schoenfeld_residuals(cox_fit_post_menopausal_female, "postmenopausal female")

```

#### Check for outliers

It’s also possible to check outliers by visualizing the deviance residuals. The deviance residual is a normalized transform of the martingale residual. These residuals should be roughtly symmetrically distributed about zero with a standard deviation of 1.

*    Positive values correspond to individuals that “died too soon” compared to expected survival times.
*    Negative values correspond to individual that “lived too long”.
*    Very large or small values are outliers, which are poorly predicted by the model.


```{r }
s <- "linear.predictions"
ggcoxdiagnostics(cox_fit_all,    type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_male,   type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_female, type = "deviance", ox.scale = s)

# The reason for bipartite cloud can be seen better in the below plots,
# where the OX axis is the observation id. The observations are sorted
# by the event year.
s <- "observation.id"
ggcoxdiagnostics(cox_fit_all,    type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_male,   type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_female, type = "deviance", ox.scale = s)

```

Let's color the points by event status.

```{r}
my_residual_plot <- function(fit, data) {
  t <- "deviance"
  r <- residuals(fit, type=t)
  data <- data %>% mutate(r = r, 
                          linear_predictors = fit$linear.predictors,
                          Status = case_when(status == 0 ~ "Censored", TRUE ~ "Deferral"))
  data %>% ggplot(aes(x=linear_predictors, y=r, color=Status)) + 
    geom_hline(yintercept = 0) +
    geom_point() +
    labs(y=t)
}
m <- my_residual_plot(cox_fit_male, scaled_sur_male)
m
```


For some reason the following doesn't work:

```{r, eval=FALSE}
g <- ggcoxdiagnostics(cox_fit_all,
                 type = "schoenfeld",
                 #type = "deviance",
                 ox.scale = "time")
g
```

#### Check for linearity of predictors

```{r,eval=FALSE}
tmp_fit <- survival::coxph(Surv(age, status) ~ bmi + log(bmi) + sqrt(bmi), 
                           data = scaled_sur_male %>% drop_na(bmi))
ggcoxfunctional(tmp_fit)#, data = sur_male %>% drop_na(bmi))
```

## Survival with time-dependent covariates

```{r}


# Cut time-series at the first deferral
until_first_deferral <- function(df) {
  has_deferrals <- df %>% group_by(donor) %>% filter(max(Hb_deferral)==1) %>% ungroup()
  has_no_deferrals <- df %>% group_by(donor) %>% filter(max(Hb_deferral)==0) %>% ungroup()
  has_deferrals <- has_deferrals %>% 
    arrange(dateonly) %>% 
    group_by(donor) %>% 
    slice(1:min(which(Hb_deferral))) %>% 
    ungroup()
  result <- bind_rows(has_no_deferrals, has_deferrals)
  return(result %>% arrange(dateonly))
}

baseline_variables <- setdiff(c(cox_variables, "female"), c("donation_count", "previous_Hb"))
# Time-independent variables
tdc_variables <- c("donation_count", "previous_Hb")  # time-dependent covariates

sex_group_df <- donations %>% select(donor, female) %>% distinct()
#don2 <- donations %>% filter(donor %in% c("0329699", "0768527"))
don2 <- donations
don <- until_first_deferral(don2)
don <- add_age(don)
baseline <- finngen %>%
  inner_join(sex_group_df, by="donor") %>%
  inner_join(dosages, by="donor") %>%
  inner_join(scores, by="donor") %>%
  mutate(across(where(is.logical), as.factor)) %>% 
  select(all_of(c("donor", baseline_variables)))
common_donor <- intersect(unique(baseline$donor), unique(don$donor))
baseline <- baseline %>% filter(donor %in% common_donor)
don <- don %>% filter(donor %in% common_donor)
tdc <- tmerge(data1=baseline, 
              data2=don %>% group_by(donor) %>% slice_tail(n=1) %>% ungroup(),  # Last donations
              id=donor, tstop=age, status = event(age, Hb_deferral))
tdc2 <- tmerge(data1=tdc, 
               data2=don,
               id=donor, 
               donation_count=cumtdc(age, !Hb_deferral, 0),
               previous_Hb=tdc(age, Hb))
```

Does the created data look sensible?

```{r}
attr(tdc2, "tcount")
```

Looks ok. See the Value section in the help page of `survival::tmerge` for explanation of the columns.

```{r Scale for time-dependent Cox model datasets}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("tstart", "tstop", "status")) & ! starts_with("snp_"),
                       myscale))
}
tdc_scaled_all <- scale_helper(tdc2)
tdc_scaled_male <- scale_helper(tdc2 %>% filter(female == FALSE))
tdc_scaled_female <- scale_helper(tdc2 %>% filter(female == TRUE))
```


```{r Time-dependent Cox formulas}
cox_tdc_formula_all <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(c(baseline_variables, tdc_variables), collapse=" + ")))
cox_tdc_formula_male <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(setdiff(c(baseline_variables, tdc_variables), "female"),
                                            collapse=" + ")))
cox_tdc_formula_female <- cox_tdc_formula_male
cox_tdc_formula_all
cox_tdc_formula_male
```

### Fit models

```{r Fit Cox models with time-dependent variables}
cox_tdc_fit_all <- coxph(cox_tdc_formula_all, tdc_scaled_all)
cox_tdc_fit_male <- coxph(cox_tdc_formula_male, tdc_scaled_male)
cox_tdc_fit_female <- coxph(cox_tdc_formula_female, tdc_scaled_female)

cox_tdc_fit_list <- list(all=cox_tdc_fit_all, male=cox_tdc_fit_male, female=cox_tdc_fit_female)


```



### Diagnostics

Can we discard the null hypothesis that the proportional hazards assumption holds?

```{r}
res <- map_dfr(cox_tdc_fit_list, extract_ph_stats, .id="model") %>% 
  pivot_wider(names_from = model, values_from=p)
pvalue_table(res)
```



### Effect sizes

```{r Plot time-dependent Cox model effect sizes}
descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))

filename <- sprintf("%s/cox_tdc_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  cox_tdc_cis <- bind_rows(map(cox_tdc_fit_list, mass_cis), .id="Group") %>%
    # bind_rows(all = mass_cis(cox_tdc_fit_all), 
    #                        male = mass_cis(cox_tdc_fit_male), 
    #                        female = mass_cis(cox_tdc_fit_female), 
    #                        .id="Group") %>%
    rename(Estimate=coef) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    left_join(descript2, by=c(Variable="Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(across(c(Estimate, low, high), exp))
  
  write_tsv(cox_tdc_cis, file=filename)
} else {
  cox_tdc_cis <- read_tsv(filename)
}


g <- cox_tdc_cis %>% 
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(cox_tdc_cis, Pretty) +
  # geom_rect(data=make_stripes(cox_tdc_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10(limits = mylimits) +
  scale_y_discrete() + 
  labs(title="Time-dependent Cox model")
if (save_figs) {
  filename <- sprintf("%s/cox_tdc_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Odds ratios of high genetic risk (TD Cox)

```{r}
tdc_cox_datas <- list(male=tdc_scaled_male %>% select(donor, all_of(genetic_variables)) %>% distinct(),
                      female=tdc_scaled_female %>% select(donor, all_of(genetic_variables)) %>% distinct())
groups <- c("male", "female")
tdc_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, tdc_cox_datas[[group]], cox_tdc_cis))
names(tdc_cox_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(tdc_cox_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_tdc_cox_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r}
filename <- sprintf("%s/deferral_tdc_cox_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- c("male", "female")
  group_names
  #weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  weighted_sum_samples <- map2(group_names, tdc_cox_datas[group_names], sample_sum_scores2, cox_tdc_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  tdc_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  tdc_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(tdc_cox_genetic_risks, file=filename)
} else {
  tdc_cox_genetic_risks <- read_tsv(filename)
}
tdc_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox male)}
genetic_scores <-  compute_total_score("male", tdc_scaled_male, cox_tdc_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
#sf <- survfit(cox_fit_male, data=scaled_sur_male)
g <- survminer::ggsurvplot(survfit(cox_tdc_fit_male, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox female)}
genetic_scores <-  compute_total_score("female", tdc_scaled_female, cox_tdc_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
g <- survminer::ggsurvplot(survfit(cox_tdc_fit_female, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

# Genetic risk using different methods

```{r}
all_genetic_risks <- bind_rows(list(bayes=bayes_genetic_risks, normal_cox=normal_cox_genetic_risks, tdc_cox=tdc_cox_genetic_risks),
                               .id="method") %>% relocate(mean, .after="group")
filename <- sprintf("%s/deferral_all_genetic_risks.tsv", table_path)
write_tsv(all_genetic_risks, file=filename)
openxlsx::write.xlsx(all_genetic_risks, file = sprintf("%s/deferral_all_genetic_risks.xlsx", table_path), overwrite=TRUE)
all_genetic_risks
```

```{r}
df1 <- bind_rows(bayes_risk_score_histograms, .id="group")
df2 <- bind_rows(normal_cox_risk_score_histograms, .id="group")
df3 <- bind_rows(tdc_cox_risk_score_histograms, .id="group")
deferral_genetic_risk_histograms <- bind_rows(bayes=df1, normal_cox=df2, tdc_cox=df3, .id="method") %>% rename(stat=Method)
filename <- sprintf("%s/deferral_genetic_risk_histograms.tsv", table_path)
write_tsv(deferral_genetic_risk_histograms, file=filename)

```

```{r}
helper <- function(df, stat) {
  df %>%
    filter(group %in% c("male", "female"), stat=={{stat}}) %>%
    ggplot(aes(x=percentile, y=value, fill=name)) +
    geom_col(position="stack") +
    GGally::geom_stripped_cols() +
    facet_grid(group~method) +
    lims(y=c(-0.4, 0.8)) +
    labs(title={{stat}}) +
    theme(#legend.position="bottom",    
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank())
}
g1 <- helper(deferral_genetic_risk_histograms, "median")
g2 <- helper(deferral_genetic_risk_histograms, "mean")
filename1 <- sprintf("%s/deferral_all_total_score_histogram_median.png", fig_path)
filename2 <- sprintf("%s/deferral_all_total_score_histogram_mean.png", fig_path)
if (save_figs) {
  ggsave(filename=filename1, g1, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
  ggsave(filename=filename2, g2, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}  
g1
g2
```




# Bayesian survival

```{r Bayesian survival, eval=FALSE}
#cox_fit_male <- survival::coxph(cox_formula, data=sur_male)
bayesian_cox <- brm(cox_formula,                     
    data = sur2, 
    family = cox(),
    file = NULL,
    control = list(max_treedepth = 15),
    cores = 4,
    iter = iterations)
```




