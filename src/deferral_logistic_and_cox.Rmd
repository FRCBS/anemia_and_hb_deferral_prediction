---
title: "Logistic regression for deferral"
author: "Jarkko Toivonen"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
  pdf_document:
    toc: yes
    toc_depth: '4'
always_allow_html: yes
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GGally)
#library(safeBinaryRegression)
library(detectseparation)  # This is better than the above package
library(brms)
library(tidybayes)
library(bayesplot)
library(posterior)
library(survival)
library(survminer)
library(ggfortify)
library(ggridges)
library(tictoc)
library(knitr)
library(kableExtra)
library(skimr)
library(patchwork)
library(ggh4x)   # For more flexible facet_grid2

recompute_dosages <- FALSE
recompute_survival <- FALSE
recompute_linearity_check <- FALSE
recompute_spline_models <- FALSE
recompute <- FALSE
save_figs <- FALSE
#base <- "~/FRCBS/blood_health_phewas/logistic_regression"
base <- "../logistic_regression"
fig_path <- sprintf("%s/figures", base)
table_path <- sprintf("%s/tables", base)
source("common.R")

# This can measure time a chunk took to execute.
# Add chunk option time_it=TRUE to each chunk your want to measure.
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- lubridate::now()
    } else {
      # calculate the time difference after a chunk
      res <- lubridate::now() - now
      # return a character string to show the time
      msg <- paste("Time for this code chunk to run:", as.numeric(res), units(res))
      message(msg)
      NULL   # Don't return the message so that it won't be printed to the resulting document.
      msg
    }
  }
}))
knitr::opts_chunk$set(echo=TRUE, time_it=TRUE)

myscale <- function(v) { return((v - mean(v, na.rm = TRUE)) / sd(v, na.rm = TRUE))}

genetic_variables <- c("prs_anemia", "prs_ferritin", "prs_hemoglobin", "snp_1_169549811", "snp_6_32617727", 
                       "snp_15_45095352", "snp_17_58358769")
snip_variables <- c("snp_1_169549811", "snp_6_32617727", "snp_15_45095352", "snp_17_58358769")
variables <- c("previous_Hb", 
               "days_to_previous_fb", "female", "age", "year", "warm_season", "hour",
               #"consecutive_deferrals",  "previous_Hb_def",  # These are too similar to other variables
               "recent_donations", "recent_deferrals", "nb_donat", 
               "weight", 
               "smoking", 
               #"bmi", 
               "snp_17_58358769", "snp_6_32617727", "snp_15_45095352", "snp_1_169549811",
               "prs_anemia", "prs_ferritin", "prs_hemoglobin")

```

# Helper functions

```{r Demographic group color palette}
# Get five equally spaced hue, and reorder so that males are blue and females are red.
# And keep this palette fixed, even if some groups are missing from some plots.
gg_color_hue <- function(n) {   # Gives 'n' equally spaced hues
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
b <- gg_color_hue(5)
cohort_colors <- c(all = b[5], male = b[4], female = b[1], pre_menopausal_female=b[2], post_menopausal_female=b[3])

```

```{r Color p-values in tables}
# Emphasize cells whose value is below the significance threshold
conditional_format <- function(c) {
  alpha <- 0.05
  cell_spec(format(c, scientific=TRUE, digits=3), 
            background = ifelse(is.na(c) | c >= alpha, "white", "red")) 
}
pvalue_table <- function(df) {
  df %>% 
    mutate(across(any_of(names(cohort_colors)), conditional_format)) %>% 
    #mutate(all = conditional_format(all)) %>% 
    #kable(escape = FALSE) %>% 
    kable(escape = TRUE) %>% 
    #kable(escape = FALSE, format.args = list(scientific=TRUE, digits=3)) %>% 
    kableExtra::kable_styling()
}
```

```{r}
# Input is a dataframe that has a factor column whose name is given as parameter
# Returns a dataframe with two columns
# stripe column has alternating values 0 and 1
# the other column contains the levels of the specified column
make_stripes <- function(df, Variable) {
  v <- df %>% pull({{Variable}})
  if (is.factor(v)) {
    v <- levels(v)
  } else {
    v <- sort(unique(v))
  }
  tibble({{Variable}} := factor(v, levels=v)) %>% 
     mutate(stripe = row_number() %% 2)
}

geom_stripes <- function(df, Variable) {
  geom_rect(data=make_stripes(df, Variable) %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Variable) + 0.5,
                        ymin = as.numeric(Variable) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE)
}
```

# Todo

* Use the usual definition for deferral, not the one we are using in the international Hb project
* Try to bootstrap the confidence intervals. NO NEED TO. THEY'LL PROBABLY LOOK LIKE THE NORMAL CIS.
* Survival analysis of deferral
* ALMOST READY Logistic regression for anemia (and survival?)
* Why Cox diagnostic plot look biparted?


# Logistic regression for deferral

## Get datas

### Get genotype data

```{r, time_it=TRUE}
snips2 <- read_tsv("~/proj/blood_health_phewas/metaresults_finngen_R_D3_ANAEMIA_IRONDEF_lead.tsv")
# snips <- tribble(
#   ~chr, ~pos, ~ref, ~alt, ~gene,
#    1, 169549811, "C", "T", "F5",
#    6,  32617727, "G", "C", "HLA-DQA1",
#   15,  45095352, "A", "G", "DUOX2",
#   17,  58358769, "C", "T", "RNF43"
# )
snips <- snips2 %>% 
  group_by(chrom) %>% 
  slice_min(order_by=pval) %>%   # Take snip with smallest p-value from each chromosome
  ungroup() %>% 
  slice_min(order_by=pval, n=4) %>%
  rename(chr=chrom)
write_tsv(snips, file = "~/FRCBS/results_for_anemia_and_deferral_article/table/anemia_meta_top_four.tsv")
openxlsx::write.xlsx(snips, file = "~/FRCBS/results_for_anemia_and_deferral_article/table/anemia_meta_top_four.xlsx", overwrite=TRUE)
knitr::kable(snips)
```

```{r}
# Returns a dataframe with one row where columns are the genotypes of individuals 
get_snip <- function(chr, pos) {
  dir <- "/home/toivoja/data/private/finngen"
  #filename <- sprintf("%s/finngen_R4_bb_chr%i_BLOOD_SERVICE_extracted_*_donor.vcf.gz", dir, chr) # R4
  #filename <- Sys.glob(filename)  # Expand the wildcard '*'
  filename <- sprintf("%s/R5/BB_finngen_R7_chr%i_BLOOD_SERVICE_BB_extracted_consentdonors.vcf.gz", dir, chr) # R5
  result_filename <- sprintf("/tmp/poista-%i.tsv", chr)
  cmd <- sprintf("bcftools query -f 'chr\tpos\t[%%SAMPLE\t]\n%%CHROM\t%%POS\t[%%TGT\t]\n' %s -r chr%i:%i > %s",
                 filename,
                 chr,
                 pos,
                 result_filename)
  print(cmd)
  system(cmd)
  df <- read_tsv(result_filename)
  df <- df %>% mutate(chr=as.numeric(str_remove(chr, "chr")))
  df <- df[-ncol(df)]  # Drop the empty last column
  return(df)
}

# Dosages is a dataframe with one column for each snip
#dosages_filename <- "~/proj/blood_health_phewas/R4_dosages.tsv"
dosages_filename <- "~/proj/blood_health_phewas/R5_dosages.tsv"
if (recompute_dosages | !file.exists(dosages_filename)) {
  df2 <- snips %>% select(chr, pos) %>% pmap_dfr(function(chr, pos) get_snip(chr, pos))
  df3 <- df2 %>% 
    pivot_longer(cols=-c(chr, pos), names_to = "donor", values_to = "genotype") %>%
    inner_join(snips) %>% 
    mutate(dosage=str_count(genotype, alt))
  dosages <- df3 %>% pivot_wider(values_from = dosage, names_from=c(chr, pos), names_prefix="snp_", id_cols = donor)
  write_tsv(dosages, dosages_filename)
} else {
  dosages <- read_tsv(dosages_filename)
}
```

```{r}
# This snip seems to have its major and minor alleles in wrong way
dosages <- dosages %>% mutate(snp_15_45095352 = 2-snp_15_45095352)
```


Do the dosages look sane? Yes.

```{r}
summary(dosages %>% mutate(across(-donor, as.factor)))
```

### PRS

```{r Get anemia weights, eval=FALSE}
anemia_weights <- read_tsv("~/proj/blood_health_phewas/prs/D3_ANAEMIA_IRONDEF.weights.txt", col_names = FALSE)
summary(anemia_weights)
g <- anemia_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Anemia weight")
g
```

```{r Get ferritin weights, eval=FALSE}
ferritin_weights <- read_tsv("~/proj/blood_health_phewas/prs/IronhomeostasisFerritinAllInterval_IasterDX_2018-11-06.wInfo.cl.txt.weights.txt", col_names = FALSE)
summary(ferritin_weights)
g <- ferritin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Ferritin weight")
g
```

```{r Get hemoglobin weights, eval=FALSE}
hemoglobin_weights <- read_tsv("~/proj/blood_health_phewas/prs/32888494-GCST90002384-EFO_0004509.h.tsv.weights.txt", col_names = FALSE)
summary(hemoglobin_weights)
g <- hemoglobin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Hemoglobin weight")
g
```

```{r Get PRS scores, results='hide', message=FALSE}
get_scores <- function(phenotype) { 
  #filenames <- sprintf("~/proj/blood_health_phewas/prs/R4_chr%i.profile", 1:22)
  filenames <- sprintf("~/proj/blood_health_phewas/prs/R5/R5_%s_%i.profile", phenotype, 1:22)
  names(filenames) <- sprintf("chr%i", 1:22)
  df <- map_dfr(filenames, 
                function(filename) {
                  read_table(filename, col_types = cols()) %>% select(donor=IID, {{phenotype}}:=SCORE)
                }, 
                .id="chr")
  scores <- df %>% group_by(donor) %>% summarise(across({{phenotype}}, sum))
  return(scores)
}
anemia_scores <- get_scores("anemia") %>% rename(prs_anemia=anemia)
ferritin_scores <- get_scores("ferritin") %>% rename(prs_ferritin=ferritin)
hemoglobin_scores <- get_scores("hemoglobin") %>% rename(prs_hemoglobin=hemoglobin)
scores <- anemia_scores %>% inner_join(ferritin_scores) %>% inner_join(hemoglobin_scores)
```

```{r}
check_normality <- function(scores, variable, pretty) {
  g1 <- scores %>% 
    ggplot(aes(x=.data[[variable]])) + 
    geom_histogram() + 
    labs(x=pretty)
  g1
  g2 <- ggqqplot(scores[[variable]]) + labs(y=pretty)
  set.seed(42)
  # Null hypothesis is that the sample is normally distributed
  s <- shapiro.test(sample(scores[[variable]], 5000)) # For some reason the sample size must be between 3 and 5000
  g1+g2 + plot_annotation(title=sprintf("Shapiro-Wilk p-value: %f", s$p.value))
}
check_normality(scores, "prs_anemia", "PRS anemia")
check_normality(scores, "prs_ferritin", "PRS ferritin")
check_normality(scores, "prs_hemoglobin", "PRS hemoglobin")
```


```{r Example plot of PRS bottom and top deciles}
# This is for presentation
g <- scores %>% 
  ggplot(aes(x=prs_anemia)) + 
  geom_histogram() + 
  geom_vline(xintercept = quantile(scores$prs_anemia, c(0.1, 0.9)), color="red") +
  labs(x="PRS anemia")
if (save_figs) {
  filename <- sprintf("%s/anemia_prs.png", fig_path)
  ggsave(filename=filename,  width = 90,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

```{r}
c <- cor(scores %>% select(-donor) %>% set_names(as.character(to_pretty_vector(names(.), descript)))) 
c2 <- c %>% as_tibble(rownames = "Phenotype")
c2
filename <- sprintf("%s/prs_correlations.tsv", table_path)
write_tsv(c2, filename)
corrplot::corrplot(c)
```


### Get Finngen

```{r}

finngen <- get_finngen(na.rm=FALSE)
finngen <- finngen %>% 
  mutate(bmi = weight / (height / 100)**2,
         smoking=ifelse(smoking %in% c("yes, occassionally", "yes, regularly"), TRUE, FALSE))
```

### Get donation information

```{r}
#donations2 <- readRDS("~/proj/interval_prediction/data/preprocessed-29-7-2021.rds")
donations2 <- readRDS("~/proj/blood_health_phewas/preprocessed_and_labeled.rds")
```


```{r}
donations <- donations2 %>% 
  mutate(female = sex == "female") %>% 
  select(-sex) %>%
  mutate(warm_season = as.logical(warm_season)) %>%
  replace_na(list(nb_donat_progesa=0, nb_donat_outside=0)) %>%
  mutate(nb_donat_outside = ifelse(nb_donat_outside < 0.0, 0.0, nb_donat_outside)) %>%
  mutate(nb_donat = nb_donat_progesa + nb_donat_outside) %>% 
  mutate(group = factor(case_when(!female ~ "male",
                                  female & age < 45 ~ "pre_menopausal_female",
                                  female & age >= 45 ~ "post_menopausal_female"))) %>% 
  arrange(dateonly) %>% 
  group_by(donor) %>% 
  mutate(donation_count = lag(cumsum(donat_phleb == "K"), default=0)) %>% 
  ungroup() %>%
  mutate(previous_Hb = case_when(previous_Hb == 0 ~ NA_real_,       # The previous_Hb was coded as 0 instead of NA for the first events
                                 TRUE             ~ previous_Hb))   # for the DLMM
```




```{r Donation summary}
summary(donations)
```

```{r Donation summary plots}
filename <- sprintf("%s/donation_summary_plot.png", fig_path)
if (recompute | !file.exists(filename)) {
  tmp <- donations %>% select(where(~ is.numeric(.x) || is.logical(.x))) %>% pivot_longer(cols = everything() ) 
  g <- tmp %>% ggplot(aes(value)) + 
    geom_histogram() + 
    facet_wrap(. ~ name, scales = "free", ncol = 4) +
    scale_x_continuous(breaks=scales::extended_breaks(n=3))
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}
```

Number of yearly donations.

```{r}
donations_per_donor <- function(df, exclude_first_time_donors = FALSE) {
  if (exclude_first_time_donors) {
    first_time_donors <- df %>%
      filter(first_event) %>%
      pull(donor)
    df <- df %>% filter(!donor %in% first_time_donors)
  }

  m <- n_distinct(df$donor)
  nrow(df) / m
}
tmp <- donations %>% 
  filter(!Hb_deferral,
         year >= 2000,
         year < 2020) %>% 
  nest_by(year, female) %>%
  rowwise() 
tmp <- tmp %>%
  mutate(donations = donations_per_donor(data),
         donations2 = donations_per_donor(data, exclude_first_time_donors=TRUE)) %>% 
  ungroup()
tmp %>%
  pivot_longer(cols=c(donations, donations2)) %>%
  ggplot(aes(x=year, y=value, color=female)) +
  geom_line() + 
  #geom_smooth(method="lm") +
  facet_wrap(~ name, labeller = as_labeller(c(donations="All donors", donations2="No first-time donors"))) +
  labs(y="Donations per donor")
```

```{r}
tmp %>% select(-data) %>% group_by(female) %>% summarise(mean = mean(donations))
```

```{r Take the last donations}
tic()
# last_donations2 <- donations %>% 
#   group_by(donor) %>% 
#   slice_max(order_by=dateonly, n=1) %>%
#   ungroup()
last_donations2 <- donations %>%   # This is faster
  arrange(dateonly) %>%
  group_by(donor) %>% 
  slice_tail(n=1) %>%
  ungroup()
toc()
```

```{r Data sizes}
sprintf("eProgesa has %i donors\n", nrow(last_donations2))
sprintf("Dosages has %i donors\n", nrow(dosages))
sprintf("Scores has %i donors\n", nrow(scores))
sprintf("Finngen has %i donors\n", nrow(finngen))
sprintf("Intersection has %i donors\n", length(intersect(intersect(intersect(last_donations2$donor, dosages$donor), scores$donor), finngen$donor)))
```
Why is the number of eProgesa donors so low in the below figure? It seems that the set counts are
the sums of intersections that belong to the set. The plot does not show show all intersections, even
when explicitly requested.

```{r}
set <- list(eProgesa = last_donations2$donor, dosages=dosages$donor, scores=scores$donor, finngen=finngen$donor)
upset <- UpSetR::upset(UpSetR::fromList(set), order.by = "freq", 
                       set_size.show=TRUE,
                       empty.intersections = TRUE,
                       set_size.scale_max = 50000, # This doesn't help to explain where donors from eProgesa disappear
                       nintersects = NA   # Show all intersections. Does not work. Six seems to be the maximum
                       # number of intersections
                       )
upset
```

```{r Check with raw eProgesa data}
# The raw donor information is used to compute more precise age of individuals
source("~/FRCBS/Hb_predictor_container/src/new_preprocess.R", chdir = TRUE)  
# NOTE: The above overwrites descript
# Hence we resource that file
source("common.R")
raw_donors <- read_donors("~/proj/interval_prediction/data/FRC.DW_DONOR.dat")
nrow(raw_donors)
length(intersect(finngen$donor, raw_donors$KEY_DONOR))
```
So, preprocessing of eProgesa data doesn't anymore drop half of the finngen donors.

### Combine all datas

```{r Combine datas}
filename <- sprintf("%s/unfiltered_last_donations.rds", base)
if (recompute | !file.exists(filename)) {
  unfiltered_last_donations <- finngen %>%
    left_join(last_donations2, by="donor") %>%
    full_join(dosages, by="donor") %>%
    full_join(scores, by="donor")
  saveRDS(unfiltered_last_donations, filename)
} else {
  unfiltered_last_donations <- readRDS(filename)
}
```

```{r Summary of last donations}
summary(unfiltered_last_donations)
```


### Average number of donations per year

```{r}
tmp2 <- donations %>% 
  semi_join(unfiltered_last_donations, by="donor") %>%
  filter(!Hb_deferral)
tmp <- tmp2 %>%
  group_by(donor, female) %>%
  filter(n() >= 5)  %>% # Select only regular donors
  summarise(n = n(), years = (max(dateonly) - min(dateonly)) / lubridate::dyears(1), .groups = "drop") %>%
  mutate(donations_per_year = n / years)
tmp_male <- tmp %>% filter(!female)  
tmp_female <- tmp %>% filter(female)
summary(tmp_male)
summary(tmp_female)
```


### Define variables

```{r}
model_variables <- c("Hb_deferral", variables)
```



```{r Filter NA values out}
cat(sprintf("Model variables are %s\n", paste(model_variables, collapse=", ")))
exclusions_deferral_logistic <- unfiltered_last_donations %>% summarise(across({{model_variables}}, ~ sum(is.na(.))))
filename <- sprintf("%s/exclusions_deferral_logistic.tsv", table_path)
write_tsv(exclusions_deferral_logistic, filename)
old_n <- nrow(unfiltered_last_donations)
last_donations <- unfiltered_last_donations %>% drop_na({{model_variables}})
cat(sprintf("Dropping %i/%i rows due to NA in model variables\n", old_n - nrow(last_donations), old_n))
filename <- sprintf("%s/unfiltered_last_donations.rds", base)
saveRDS(last_donations, filename)
```

```{r}
group_options <- c("all", "male", "pre_menopausal_female", "post_menopausal_female")
helper <- function(df, group_opt) {
  stopifnot(group_opt %in% group_options)
  if (group_opt != "all")
    df <- df %>% filter(group==group_opt)
  n <- nrow(df)
  cases <- sum(df$Hb_deferral)
  controls <- n - cases
  prevalence <- 100 * cases / n
  tibble(group=group_opt, n=n, cases=cases, controls=controls, `prevalence (%)`=prevalence)
}
deferral_stats <- expand_grid(group=group_options)
deferral_stats <- deferral_stats %>% pmap_dfr(function(group) helper(last_donations, group))
print(deferral_stats, n=Inf)
filename <- sprintf("%s/deferral_stats.tsv", table_path)
write_tsv(deferral_stats, filename)
```


### Summaries

```{r}
summary(last_donations %>% mutate(across(starts_with("snp_"), as.factor)))
```

```{r Summary plots of last donations}
tmp2 <- last_donations %>% 
  select(where(is.numeric)) %>% 
  pivot_longer(cols = everything(), names_to = "Variable" ) %>% 
  inner_join(descript %>% mutate(Variable = str_replace_all(Variable, "`", "")), 
             by="Variable")
  
myorder <- c(descript$Pretty[str_starts(descript$Pretty, "SNP")], descript$Pretty[str_starts(descript$Pretty, "PRS")])

g2 <- tmp2 %>% 
  mutate(Pretty = fct_relevel(Pretty, myorder)) %>% 
  ggplot(aes(value)) + 
  geom_histogram() + 
  facet_wrap(. ~ Pretty, scales = "free", ncol = 4) +
  scale_y_continuous(breaks=scales::extended_breaks(n=3))
if (save_figs) {
  filename <- sprintf("%s/variable_summary.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g2
```

```{r Summaries of stratified data}
for (g in c("male", "pre_menopausal_female", "post_menopausal_female")) {
  cat(sprintf("\n*** Group %s ***\n\n", g))
  print(summary(last_donations %>% filter(group == {{g}}) %>% mutate(across(starts_with("snp_"), as.factor))))
}
```

```{r Contingency tables for deferral and RNF43}
helper <- function(g, df) {
  cat(sprintf("\n*** %s ***\n", g))
  if (g != "all")
    df <- df %>% filter(group==g)
  print(table(df %>% select(snp_17_58358769, Hb_deferral)))
}
walk(c("all", "male", "pre_menopausal_female", "post_menopausal_female"), helper, last_donations)
```

```{r Compute genotype distributions, results='asis'}
tmp <- map_dfr(snip_variables, 
              function(snp) { 
                as_tibble(table(
                  last_donations %>% 
                    select(all_of(snp), Hb_deferral)
                )) %>% 
                  pivot_longer(cols=all_of(snp))
              }
  )
genotype_distribution <- tmp %>% 
  pivot_wider(names_from = Hb_deferral, values_from = n) %>%
  rename(case=`TRUE`, control=`FALSE`) %>% 
  group_by(name) %>% 
  mutate(case_freq = case / sum(case),
         control_freq = control / sum(control)) %>%
  ungroup() %>%
  mutate(value = as.integer(value)) %>%
  rename(variable=name, dosage=value)
filename <- sprintf("%s/deferral_genotype_distribution.tsv", table_path)
write_tsv(genotype_distribution, filename)
kable(genotype_distribution, format="html", digits=2)
#genotype_distribution
```

```{r}
g <- genotype_distribution %>% 
  pivot_longer(cols=c(case_freq, control_freq), values_to = "frequency", names_to = "status") %>% 
  mutate(status = str_replace(status, "_freq", ""),
         variable = factor(variable, snip_variables)) %>%
  ggplot(aes(x=dosage, y=frequency, fill=status)) +
  geom_col(position="dodge") +
  facet_grid(~variable)
g
# if (save_figs) {
#   filename <- sprintf("%s/deferral_genotype_distributions.png", fig_path)
#   ggsave(filename=filename,  width = 90,  height=90, units="mm", dpi=300, scale=1.0, device="png")
# }
```


### Split the data to train, validate, and test sets

```{r, eval=FALSE}
train <- last_donations %>% filter(label == "train")
validate <- last_donations %>% filter(label == "validate")
test <- last_donations %>% filter(label == "test")
nrow(train)
nrow(validate)
nrow(test)
```



### Split data into demographic groups and scale

```{r Scale data for logistic regressions}
data <- last_donations %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_male <- last_donations %>% 
  filter(group == "male") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_female <- last_donations %>% 
  filter(group != "male") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_pre_menopausal_female <- last_donations %>% 
  filter(group == "pre_menopausal_female") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_post_menopausal_female <- last_donations %>% 
  filter(group == "post_menopausal_female") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
  
```

```{r Get normalizing constants for each variable}
stat_helper <- function(df) {
  df %>% summarise(across(where(is.numeric) & ! starts_with("snp_"), 
                          list(mean=~mean(.x, na.rm=TRUE), 
                               sd=~sd(.x, na.rm=TRUE))))
}
stat_helper2 <- function(df) { # long form version
  df %>%
    select(where(is.numeric) & ! starts_with("snp_")) %>% 
    pivot_longer(cols=everything()) %>%
    group_by(name) %>% 
    summarise(mean=mean(value, na.rm=TRUE), sd=sd(value, na.rm=TRUE))
}
# For some reason this didn't work!
# variable_stats <- map_dfr(
#   list(stat_helper(last_donations %>% filter(group=="male")),
#        stat_helper(last_donations %>% filter(group=="pre_menopausal_female"))),
#   stat_helper)
dfall <- stat_helper2(last_donations)
dfm <- stat_helper2(last_donations %>% filter(group=="male"))
dfpre <- stat_helper2(last_donations %>% filter(group=="pre_menopausal_female"))
dfpost <- stat_helper2(last_donations %>% filter(group=="post_menopausal_female"))
variable_stats <- bind_rows(all=dfall, male=dfm, pre_menopausal_female=dfpre, post_menopausal_female=dfpost, .id="group")
rm(dfall, dfm, dfpre, dfpost)
filename <- sprintf("%s/deferral_variable_stats.rds", base)
saveRDS(variable_stats, filename)
```

### Correlation between hemoglobin PRS and hemoglobin

```{r}
r2_table <- tribble(~group, ~data,
                    "male", data_male,
                    "pre_menopausal_female", data_pre_menopausal_female,
                    "post_menopausal_female", data_post_menopausal_female)
                    
r2_table <- r2_table %>%
  mutate(lm = map(data, function(df) lm(Hb ~ prs_hemoglobin, data=df)),
         r2 = map(lm, function(lm) broom::glance(lm)$r.squared),
         label = sprintf("R^2==%.2f", r2))

#r2 <- summary(lm(Hb ~ prs_hemoglobin, data=last_donations))$r.squared
#mylabel <- sprintf("R^2==%.2f", r2)

# Use parse=TRUE instead of bquote:
# https://github.com/tidyverse/ggplot2/issues/4644
g <- last_donations %>% ggplot(aes(x=prs_hemoglobin, y=Hb)) + 
  geom_point(alpha=0.1) + geom_smooth() + labs(x="Hemoglobin PS") +
  geom_text(data = r2_table, mapping=aes(label=label), x=1e-5, y=100, color="black",  fontface="bold", parse=TRUE) +
  facet_wrap(~group)
g
if (save_figs) {
  filename <- sprintf("%s/hb_hb_prs_scatter.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}

```
Not a huge correlation.

## Total genetic risk


```{r}
total <- dosages %>% rowwise(donor) %>% summarise(total=sum(c_across(everything())))
g <- total %>% ggplot(aes(x=total)) + geom_bar() 
g + labs(x="Total dosage")
```

## RFN43 boxplot

```{r}
filename <- "/tmp/boxplot.png"
counts <- last_donations %>% count(gender, snp_17_58358769) %>%
  mutate(across(snp_17_58358769, as.factor),
         label=sprintf("n=%i", n))
g <- last_donations %>% 
  mutate(across(snp_17_58358769, as.factor)) %>%
  ggplot(aes(y=Hb, x=snp_17_58358769)) +
  ggforce::geom_sina(color="gray") +
  geom_boxplot() +
  facet_grid(~ gender)+
  geom_text(data=counts, aes(x=snp_17_58358769, y = 85, label=label), size=5) + 
  labs(x="Number of alternative alleles", y="Hemoglobin (g/L)", 
       title="Chromosome 17, position 58358769 (RNF43)" ) +
  lims(y=c(85, 205)) + 
  theme_gray(base_size = 15)
ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
g
```



## Logistic regression


```{r Frequentist logistic regression formula}
freq_variables <- setdiff(variables, "female")
freq_formula <- as.formula(sprintf("Hb_deferral ~ %s", paste(freq_variables, collapse=" + ")))
freq_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", paste(variables, collapse=" + ")))
print(freq_formula)
print(freq_formula_all)
datas <-list(all=data, male=data_male, female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
freq_formulas <- list(all=freq_formula_all, male=freq_formula, female=freq_formula,
             pre_menopausal_female=freq_formula,
             post_menopausal_female=freq_formula)

```

### Fit models

```{r Detect for separation, eval=FALSE}
# 'safeBinaryRegression' package sucks, I now use 'detectseparation' instead!
fit <- stats::glm(freq_formula_all,
#fit <- safeBinaryRegression::glm(my_formula,
             #data = tmp, # For safeBinaryRegression
             data = data,
             method="detect_separation",
             family = "binomial")
fit
```

No separation detected. Lets fit the model.

```{r}
filename <- sprintf("%s/fit.rds", base)
if (recompute | !file.exists(filename)) {
  fit <- stats::glm(freq_formula_all,
             data = data,
             family = binomial)
  saveRDS(fit, filename)
} else {
  fit <- readRDS(filename)
}
```

```{r}
fit_freq_helper <- function(group, data, formula) {
  filename <- sprintf("%s/freq_fit_%s.rds", base, group)
  if (recompute | !file.exists(filename)) {
    freq_fit <- stats::glm(formula,
                           data = data,
                           family = binomial)
    saveRDS(freq_fit, filename)
  } else {
    freq_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(freq_fit)))
}
#summary(bayesian_fit_all)
freq_input <- tibble(group=names(cohort_colors),
                         data=datas,
                         formula=freq_formulas)
freq_fits <- pmap_dfr(freq_input, fit_freq_helper)
freq_fits_list <- deframe(freq_fits)
```

If safeBinaryRegression was used, it complained that all variables were causing separation among the sample points.
I disabled the package.

```{r}
summary(fit)
```

Why is the effect of 'female' variable negative? Positive effect would be expected! BECAUSE MALES AND FEMALE HAVE DIFFERENT HB LEVELS AND HB_THRESHOLDS!!!

```{r}
table(data %>% select(female, Hb_deferral))  # This looks as expected
myvariables <- unique(c("female", variables)) # Move female to front of the list
# Add one variable at time to model and fit it
test_df <- tibble(variables = map(1:length(myvariables), function(i) myvariables[1:i]),
                  added_variable = map_chr(variables, function(v) tail(v, n=1)),
                  formula = map(variables, 
                                function(v) as.formula(sprintf("Hb_deferral ~ %s", paste(v, collapse=" + ")))),
                  fit = map(formula, function(f) stats::glm(f, data=data, family=binomial))
                  )
test_df
test_result <- pmap_dfr(test_df, function(variables, added_variable, formula, fit) {
  broom::tidy(fit) %>% mutate(added_variable=factor(added_variable, levels = myvariables))
})

# In the plot variables are added to the model starting from the top
test_result %>% filter(term == "femaleTRUE") %>% 
  ggplot(aes(x=estimate, y = fct_rev(added_variable))) +
  geom_point()
```

Let's see if interaction help with this.

```{r}
int_fit <- stats::glm(Hb_deferral ~ female + previous_Hb + female:previous_Hb, data=data, family=binomial)
# Compare with the model with female predictor
test_df %>% pluck("fit", 1)
# Compare with the model without interaction
test_df %>% pluck("fit", 2)
# With interactions
int_fit
```

Well, actually this is expect as males and females have different hb levels and hb thresholds.

### Diagnostics

#### Residual deviance

Residual deviance is significantly smaller than null deviance so the predictors offer significant information.
The median of deviance residuals is not very close to zero, which means there could be a small bias. The distribution of residuals should
be approximately normal: [What do the residuals in a logistic regression mean](https://stats.stackexchange.com/questions/1432/what-do-the-residuals-in-a-logistic-regression-mean)

```{r Plot the deviance residuals}
last_donations %>% #drop_na() %>% 
  mutate(residual=residuals(fit)) %>% ggplot(aes(x=residual)) + geom_histogram()
```


For explanation of deviance see:

* [Interpreting Residual and Null Deviance in GLM R](https://stats.stackexchange.com/questions/108995/interpreting-residual-and-null-deviance-in-glm-r)
* [Interpreting Generalized Linear Models](https://www.datascienceblog.net/post/machine-learning/interpreting_generalized_linear_models/)

```{r Pretty logistic formula}
# This is for presentation purposes
s <- as.character(formula(fit))
conv <- setNames(descript$Pretty, descript$Variable)
conv <- conv[conv != "Hemoglobin"]
cat(sprintf("Hb deferral ~ %s", str_replace_all(s[[3]], conv)))
```

#### Default glm diagnostics

```{r Diagnostic plots for linear model}
plot(fit, which=c(1,2,3,4,5))
```
One should not use the above plots to interpret results of logistic regression according to 
https://stats.stackexchange.com/questions/234998/logistic-regression-diagnostic-plots-in-r

The advise on page http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/
is to check for

* linearity
* influential points using Cook's distance (above plot showed no influential points)
* multicollinearity using Variance inflation factors


#### Check for linearity

```{r}
probabilities <- predict(fit, type = "response")
```

```{r}
#variables <- str_split(as.character(formula(fit))[[3]], " \\+ ")[[1]]
#variables <- str_subset(variables, "`", negate=TRUE)
data2 <- data %>% 
  select(all_of(variables)) %>% 
  drop_na() %>% 
  select(where(is_double)) %>% 
  mutate(logit=log(probabilities/(1-probabilities)))
```

```{r Relation between each predictor with the logit scale response}
filename <- sprintf("%s/linearity_check.png", fig_path)
if (recompute_linearity_check | !file.exists(filename)) {
  g <- data2 %>%
    #slice_sample(n=1000) %>% # For quick testing purposes
    #mutate(across(c(consecutive_deferrals, recent_deferrals), function(x) log(x))) %>%
    pivot_longer(cols = -logit, names_to = "predictor") %>%
    ggplot(aes(logit, value))+
    geom_point(size = 0.5, alpha = 0.5) +
    geom_smooth(method = "loess") + 
    theme_bw() + 
    facet_wrap(~predictor, scales = "free_y")
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}

```

All variables except maybe consecutive_deferrals and recent_deferrals seem to be linearly related to the logit scale response.

Same as above but the axes are reversed:

```{r}
filename <- sprintf("%s/linearity_check2.png", fig_path)
if (recompute_linearity_check | !file.exists(filename)) {
  g <- data2 %>%
    head(1000) %>%
    #select(-recent_deferrals & -year & !starts_with("snp")) %>%
    #slice_sample(n=1000) %>% # For quick testing purposes
    #mutate(across(c(consecutive_deferrals, recent_deferrals), function(x) log(x))) %>%
    pivot_longer(cols = -logit, names_to = "predictor") %>%
    inner_join(variable_stats %>% filter(group=="all"), by=c(predictor="name")) %>%  # Add normalizing constants
    mutate(value = value*sd+mean) %>%   # normalize
    ggplot(aes(value, logit)) +
    geom_point(size = 0.5, alpha = 0.5) +
    geom_smooth(method = "loess") +
    labs(y="Log odds of Hb-deferral") +
    theme_bw() + 
    facet_wrap(~predictor, scales = "free_x")
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}
```

#### Check for multicollinearity

```{r Check for multicollinearity}
#sort(car::vif(fit), decreasing = TRUE)
freq_vifs <- t(map_dfr(freq_fits_list, function(x) as_tibble(t(car::vif(x))))) %>% as_tibble(rownames = "Variable")
colnames(freq_vifs) <- c("Variable", names(freq_fits_list))
filename <- sprintf("%s/deferral_vifs.tsv", table_path)
write_tsv(freq_vifs, filename)
```
According to https://www.statisticshowto.com/variance-inflation-factor/
VIF value greater than 5 means that it is highly correlated with other predictors.
So, it seems that weight and bmi are correlated, of course. And probably consecutive_deferrals and previous_Hb_def.

The below figure is slow to compute.

```{r Correlations between variables, eval=FALSE}
# Function to return points and geom_smooth
# allow for the method to be changed
my_fn <- function(data, mapping, method="loess", ...){
      p <- ggplot(data = data, mapping = mapping) + 
      geom_point() + 
      geom_smooth(method=method, ...)
      p
    }
g <- ggpairs(data2 %>% select(-logit), lower = list(continuous = my_fn))
if (save_figs) {
  filename <- sprintf("%s/correlations.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
```

```{r}
c <- data %>% 
  select(all_of(variables)) %>% 
  set_names(as.character(to_pretty_vector(names(.), descript))) %>%
  cor()
mynames <- str_sort(colnames(c), numeric=TRUE)
c <- c[mynames, mynames]
c2 <- c %>% as_tibble(rownames = "Phenotype")
c2
filename <- sprintf("%s/deferral_correlations.tsv", table_path)
write_tsv(c2, filename)
filename <- sprintf("%s/deferral_correlations.pdf", fig_path)
if (save_figs) cairo_pdf(filename)
corrplot::corrplot(c)
if (save_figs) dev.off()
```

### Effect sizes

The profiling method of MASS and my simple approximation seem to produce same results.
Next, check if bootstrapping would change this.

```{r Coefficients and confidence intervals}
self_made_cis <- function(fit) {
  c3 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c <- c3 %>% 
    mutate(low = Estimate - 1.96*`Std. Error`, 
           high = Estimate + 1.96*`Std. Error`) 
  return(c)
}
mass_cis <- function(fit) {   # This uses profiling based method from MASS
  c3 <- rownames_to_column(as.data.frame(confint(fit)), var="Variable") %>% as_tibble()
  c4 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c3 <- c3 %>% inner_join(c4, by="Variable")
  c <- c3 %>% 
    rename(low = `2.5 %`, high = `97.5 %`)
  return(c)
  
}

descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))
freq_cis <- bind_rows("Self-made" = self_made_cis(fit), "MASS" = mass_cis(fit), .id="Method") %>%
  left_join(descript2, by=c(Variable="Variable2")) %>%
  filter(Variable != "(Intercept)") %>%
  mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
  mutate(Pretty = as.factor(Pretty)) %>%
  mutate(across(c(Estimate, low, high), exp))

freq_cis %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Method)) +
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_pointrange(position=position_dodge(width=1)) + 
  labs(title="Frequentist", x="Odds ratio", y="Standardized variables") + 
  scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/normalised_effect_sizes.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}

```


## Bayesian logistic regression



```{r Define Bayesian logistic models}
iterations <- 1000
cores <- 4   # Run out of memory with four cores
bayesian_variables <- setdiff(variables, "female")
bayes_formula <- as.formula(sprintf("Hb_deferral ~ %s", paste(bayesian_variables, collapse=" + ")))
print(bayes_formula)
bayes_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", paste(variables, collapse=" + ")))
print(bayes_formula_all)
```


```{r}
# Perform rank-based inverse normal transform on the PRS variables
inv_transform <- function(df) {
  df <- df %>%
    mutate(across(c("prs_anemia", "prs_ferritin", "prs_hemoglobin"), RNOmni::RankNorm, k=0.5))
  df
}
datas <-list(all=data, male=data_male, female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
# Since the scores are already normally distributed, the following didn't have any effect.
#datas <- map(datas, inv_transform)
bayesian_formulas <- list(all=bayes_formula_all, male=bayes_formula, female=bayes_formula,
             pre_menopausal_female=bayes_formula,
             post_menopausal_female=bayes_formula)
```

Flat prior is used for every parameter except the Intercept and sigma are student_t distributed.

```{r Show the used priors, eval=FALSE}
get_prior(bayes_formula, data_male)
```

```{r}
for (group in names(datas)) {
  tmp <- datas[[group]]
  cat(sprintf("Logistic regression, group: %s, n %i, cases %i, controls %i, prevalence %.1f%%\n",
              group,
              nrow(tmp),
              sum(tmp$Hb_deferral),
              sum(!tmp$Hb_deferral),
              mean(tmp$Hb_deferral)*100))
}
```

### Fit models

```{r Fit all Bayesian models}
fit_bayesian_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_fit_%s.rds", base, group)
  if ((recompute | !file.exists(filename))) { # && 
      #! group %in%  c("all", "female")) {   # This is taking lots of resource, hence it is not run!
    cat(sprintf("Fitting Bayesian logistic model for Hb-deferral on group %s\n", group))
    bayesian_fit <- brm(formula,
                            data = data, 
                            family = bernoulli(),
                            file = NULL,
                            control = list(max_treedepth = 14),
                            #control = if (group == "all") list(max_treedepth = 13) else list(max_treedepth = 14),
                            #refresh = 0,
                            cores = cores,
                            iter = iterations
    )
    saveRDS(bayesian_fit, filename)
  } else {
    cat(sprintf("Loading prefitted Bayesian logistic model for Hb-deferral on group %s\n", group))
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
#summary(bayesian_fit_all)
bayesian_input <- tibble(group=names(cohort_colors),
                         data=datas,
                         formula=bayesian_formulas)
bayesian_fits <- pmap_dfr(bayesian_input, fit_bayesian_helper)
bayesian_fits_list <- deframe(bayesian_fits)
```



### Diagnostics

#### Trace
```{r}
#mcmc_plot(bayesian_fit, type = "trace", n_warmup = 500)
# Include the warmup iterations for comparison
# bayesian_fits <- tibble(id=c("all", "male", "pre_menopausal_female", "post_menopausal_female"),
#                         fit=list(bayesian_fit_all, bayesian_fit_male, bayesian_fit_pre_menopausal_female, bayesian_fit_post_menopausal_female))
helper <- function(group, fit) {
  bp <- bayesplot::mcmc_trace(as_draws_array(fit, inc_warmup = TRUE), n_warmup = iterations/2)
  if (save_figs) {
    filename <- sprintf("%s/traces_%s.pdf", fig_path, group)
    ggsave(filename=filename,  plot=bp, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="pdf")
  }
  bp
}
#walk2(bayesian_fits$id, bayesian_fits$fit, helper)
pmap(bayesian_fits, helper)
```

#### Auto-correlation

Is there something wrong with this? No, one just needs to zoom it!

```{r}
#mcmc_plot(bayesian_fit, type = "acf_bar")
#map(deframe(bayesian_fits), mcmc_plot, type = "acf_bar")
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "acf_bar") + labs(title=group)
  if (save_figs) {
    filename <- sprintf("%s/auto_correlations_%s.pdf", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="pdf")
  }
  g
}
#pmap(bayesian_fits, ~ mcmc_plot(.y, type = "acf_bar") + labs(title=.x))
pmap(bayesian_fits, helper)

```

Check Rhats to see if we converged.

```{r}
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "rhat") + labs(title=group)
  if (save_figs) {
    filename <- sprintf("%s/rhats_%s.pdf", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="pdf")
  }
  g
}
#map2(bayesian_fits$id, bayesian_fits$fit, helper) # These are all equivalent, but the last one is the shortest
pmap(bayesian_fits, helper)
#pmap(bayesian_fits, ~ mcmc_plot(.y, type = "rhat") + labs(title=.x))
```

We reached convergence.

#### Effect distributions

```{r , message=FALSE, warning=FALSE}
variables2 <- descript2 %>% 
  filter(Variable %in% bayesian_variables) %>%
  arrange(Pretty) %>% pull(Variable2) %>% unique %>% rev
bvariables <- if_else(variables2 != "(Intercept)", sprintf("b_%s", variables2), "b_Intercept")
forest_plot <- function(fit, id) {
  p <- mcmc_plot(fit, 
                 type = "areas",
                 prob = 0.95,        # This is the width of the light blue shaded area ("inner"). 
                 prob_outer = 1.0,   # This is the width of the outline ("outer")
                 # The dark blue comes from the "point" estimate but I don't know how to turn it off.
                 variable = bvariables,
                 area_method = "equal area",
                 transformations = "exp"
  ) +
    geom_vline(xintercept = 1, color = "grey") +
    labs(x="Odds ratio") + 
    scale_x_log10()
  if (save_figs) {
    filename <- sprintf("%s/bayesian_area_plots_%s.png", fig_path, id)
    ggsave(filename=filename,  plot=p, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  p
}

# This self-made version has pretty labels unlike the previous function
forest_plot2 <- function(fit, id) {
  a <- as.array(fit, variable=bvariables)
  tmp <- mcmc_areas_data(a, 
                         prob = 0.95,
                         area_method = "equal area",
                         #variable = variables2,
                         transformations = "exp"
  )
  
  tmp2 <- tmp %>% 
    filter(parameter != "exp(b_intercept)") %>% 
    mutate(parameter = str_match(parameter, "exp\\(b_(.*)\\)")[,2]) %>%
    inner_join(descript2, by=c(parameter = "Variable2")) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Pretty = fct_rev(Pretty))
  
  g2 <- tmp2 %>% 
    filter(interval == "inner") %>% 
    ggplot(aes(x=x, y=Pretty, height=plotting_density)) + 
    geom_ridgeline(scale=0.9) +  # Shaded area ("inner")
    geom_ridgeline(mapping=aes(x=x, y=Pretty, height=plotting_density), # The black outline ("outer")
                   data=tmp2 %>% filter(interval=="outer"), 
                   fill=NA, scale=0.9) +
    scale_y_discrete() +
    labs(x="Odds ratio", y="Variable") +
    scale_x_log10()
}

```

```{r}
g <- forest_plot2(bayesian_fits_list$all, "all")
g
```


```{r}
g <- forest_plot2(bayesian_fits_list$male, "male")
g
```

```{r}
g <- forest_plot2(bayesian_fits_list$female, "female")
g
```


```{r}
g <- forest_plot2(bayesian_fits_list$pre_menopausal_female, "pre_menopausal_female")
g
```

```{r}
g <- forest_plot2(bayesian_fits_list$post_menopausal_female, "post_menopausal_female")
g
```

### Effect sizes

```{r}
get_bayes_intervals <- function(bayesian_fit) {
  bayes_cis <- mcmc_intervals_data(as_draws_array(bayesian_fit), 
                                   point_est="mean", regex_pars = "^b_.*", prob = 0, prob_outer = 0.95)
  bayes_cis <- bayes_cis %>% 
    rename(Variable=parameter, Estimate=m, low=ll, high=hh) %>%
    mutate(Variable = str_remove(Variable, "b_")) %>%
    mutate(Variable = if_else(Variable=="Intercept", "(Intercept)", Variable)) %>%
    select(Variable, low, Estimate, high)
  return(bayes_cis)
}
pretty_bayes_intervals <- function(bayesian_fits_list) {
  map_dfr(bayesian_fits_list, get_bayes_intervals, .id="Group") %>%
    left_join(descript2, by=c(Variable = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    filter(Variable != "(Intercept)") %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    mutate(across(c(Estimate, low, high), exp))
}
```

```{r}
filename <- sprintf("%s/bayes_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  bayes_cis <- pretty_bayes_intervals(bayesian_fits_list)
  write_tsv(bayes_cis, file=filename)
} else {
  bayes_cis <- read_tsv(filename)
}
```

```{r}
```

```{r Compare confidence intervals of Bayesian method on three strata}
g <- bayes_cis %>% 
  mutate(Group = factor(Group, levels = names(cohort_colors)),
         Pretty = factor(Pretty, levels = str_sort(unique(Pretty), numeric=TRUE))) %>%
  mutate(across(c(Group, Pretty), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(bayes_cis, Pretty) +
  # geom_rect(data=make_stripes(bayes_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) + 
  labs(title = "Bayesian", x="Odds ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10() +
  scale_y_discrete()  # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale

if (save_figs) {
  filename <- sprintf("%s/bayes_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Check linearity

```{r}
#tmp <-as.character(bayes_formula)
#tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3]) # Formula converted to a string
full_spline_variables <- c("previous_Hb", "days_to_previous_fb", "age", "year", "hour", #"recent_donations", "recent_deferrals",
                           "nb_donat", "weight") # Make these variables use splines
full_spline_formula <- sprintf("Hb_deferral ~ %s", paste(sprintf("s(%s)", full_spline_variables), collapse=" + "))
#full_spline_formula <- as.formula(str_replace_all(tmp2, paste(full_spline_variables, collapse="|"), "s(\\0)"))
print(full_spline_formula)
full_spline_datas <-list(#all=data, 
             male=data_male, #female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
full_spline_formulas <- list(#all=spline_formula_all, 
                          male=full_spline_formula, #female=spline_formula,
             pre_menopausal_female=full_spline_formula,
             post_menopausal_female=full_spline_formula)
```

```{r}
#filename <- sprintf("%s/full_spline_fit.rds", base)
#saveRDS(full_spline_fit, filename)
# This seems to run out-of-memory when I tried to rerun it!
fit_full_spline_helper <- function(group, data, formula) {
  filename <- sprintf("%s/full_spline_fit_%s.rds", base, group)
  if (recompute_spline_models | !file.exists(filename)) {
    cat(sprintf("Fitting Bayesian logistic model with splines for Hb-deferral on group %s\n", group))
    bayesian_fit <- brm(formula,
                            data = data,# %>% slice_sample(n=10000), 
                            family = bernoulli(),
                            file = NULL,
                            control = list(max_treedepth = 15, adapt_delta = 0.99),
                            #refresh = 0,
                            cores = cores,
                            iter = 2000,
                            warmup = 1000
    )
    saveRDS(bayesian_fit, filename)
  } else {
    cat(sprintf("Loading prefitted Bayesian logistic model with splines for Hb-deferral on group %s\n", group))
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
#summary(bayesian_fit_all)
full_spline_input <- tibble(group=setdiff(names(cohort_colors), c("all", "female")),
                         data=full_spline_datas,
                         formula=full_spline_formulas)
full_spline_fits <- pmap_dfr(full_spline_input, fit_full_spline_helper)
full_spline_fits_list <- deframe(full_spline_fits)
```

```{r Full spline plotting functions}
#plot(conditional_smooths(spline_fit, smooths = "s(age)"), ask = FALSE)
# Returns a tibble with columns for variable, x-coordinate, estimate, upper and lower bound
#   effect1__ cond__ estimate__  se__   lower__ upper__ name        value
#   <dbl>     <fct>  <dbl>       <dbl>  <dbl>   <dbl>   <chr>       <dbl>
helper <- function(fit) {
  x <- conditional_smooths(fit)
  # bind_rows(
  #   pivot_longer(x[[1]], cols = days_to_previous_fb),
  #   pivot_longer(x[[2]], cols = age),
  #   pivot_longer(x[[3]], cols = weight)
  #)
  bind_rows(map2(1:length(full_spline_variables), full_spline_variables, function(i, n) pivot_longer(x[[i]], cols = n)))
}

# Extract these from the fit for abline function.
# Returns a tibble with columns for variable name, intercept and slope.
helper2 <- function(fit) {
  t <- as_tibble(fit)
  df <- t %>% 
    rename_with(.cols=everything(), .fn = function(x) str_remove(x, "^b_")) %>%
    select(all_of(full_spline_variables), Intercept) %>% 
    summarise(across(everything(), mean)) %>% 
    pivot_longer(cols=-Intercept, values_to = "slope") %>% 
    rename(intercept = Intercept)
  return(df)
}

# This is for renaming the facet titles
plot_labeller <- function(group){
    case_when(group == "pre_menopausal_female" ~ "pre",
              group == "post_menopausal_female" ~ "post",
              TRUE ~ group)
}
```


```{r Full spline curves and lines}
evaluated_full_splines <- map_dfr(full_spline_fits_list, helper, .id="group") %>%
  mutate(group = factor(group))

# For comparison take the slopes for each linear predictor from the earlier models
line_coeffs <- map_dfr(bayesian_fits_list, helper2, .id="group") %>%
  filter(!group %in% c("all", "female")) %>%
  #filter(group == "all") %>%
  mutate(group = factor(group)) %>%
  mutate(intercept = 0)  # Don't use these after all for comparability with the splines

```


ggh4x::facet_grid2 depends on internals of ggplot2. Therefore it tends to break when ggplot2 is updated.
Some kind of weird error message is issued. Like the following:
`Error in rbind_dfs(values[has_all]) : could not find function "rbind_dfs"`
Solution for this is to include a newer version of ggh4x, which hopefully fixes the problem.

```{r Plot scaled full splines}
g_scaled <- evaluated_full_splines %>% 
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), data = line_coeffs) +
  labs(title="Hb deferral, scaled", y="s(value)") +
  #lims(y=c(-10, 5)) +
  # facet_grid(group ~ name,
  #            scales = "free",
  #            labeller = labeller(group=plot_labeller))
  ggh4x::facet_grid2(group ~ name,
             scales = "free",
             labeller = labeller(group=plot_labeller),
             independent = TRUE)
if (save_figs) {
  filename <- sprintf("%s/full_splines_scaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_scaled
```

```{r Plot unscaled full splines}
  
scaled_evaluated_full_splines <- evaluated_full_splines %>% 
  #filter(group == "all") %>%
  inner_join(variable_stats, by=c("group", "name")) %>%
  mutate(value = value * sd + mean) 

g_unscaled <- scaled_evaluated_full_splines %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), 
              data = line_coeffs %>%
                filter(group != "female") %>%
                left_join(variable_stats, by=c("group", "name")) %>% 
                mutate(intercept = -slope*mean/sd, slope = slope / sd)) +
  labs(title="Hb deferral, unscaled", y="s(value)") +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE,
                    labeller = labeller(group=plot_labeller))
  # facet_grid(rows=vars(group), cols=vars(name), scales = "free",
  #                    labeller = labeller(group=plot_labeller))
if (save_figs) {
  filename <- sprintf("%s/full_splines_unscaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_unscaled
```


## Try splines for some variables

```{r Define formulas with splines}
tmp <-as.character(bayes_formula)
tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3]) # Formula converted to a string
spline_variables <- c("age", "weight", "days_to_previous_fb") # Make these variables use splines
spline_formula <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), "s(\\0)"))
print(spline_formula)
```

```{r}
spline_datas <-list(#all=data, 
             male=data_male, #female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
spline_formulas <- list(#all=spline_formula_all, 
                          male=spline_formula, #female=spline_formula,
             pre_menopausal_female=spline_formula,
             post_menopausal_female=spline_formula)
```


### Fit models

```{r Fit all Bayesian spline models}
fit_bayesian_spline_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_spline_fit_%s.rds", base, group)
  if (recompute_spline_models | !file.exists(filename)) {
    bayesian_fit <- brm(formula,
                            data = data, 
                            family = bernoulli(),
                            file = NULL,
                            control = list(max_treedepth = 15, adapt_delta = 0.99),
                            refresh = 0,
                            cores = cores,
                            iter = 11000,
                            warmup = 1000
    )
    saveRDS(bayesian_fit, filename)
  } else {
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
#summary(bayesian_fit_all)
bayesian_spline_input <- tibble(group=setdiff(names(cohort_colors), c("all", "female")),
                         data=spline_datas,
                         formula=spline_formulas)
spline_fits <- pmap_dfr(bayesian_spline_input, fit_bayesian_spline_helper)
spline_fits_list <- deframe(spline_fits)
```


```{r Plot scaled splines}
#plot(conditional_smooths(spline_fit, smooths = "s(age)"), ask = FALSE)
helper <- function(fit) {
  x <- conditional_smooths(fit)
  bind_rows(
    pivot_longer(x[[1]], cols = days_to_previous_fb),
    pivot_longer(x[[2]], cols = age),
    pivot_longer(x[[3]], cols = weight)
  )
}
# Extract these from the fit for abline function.
helper2 <- function(fit) {
  t <- as_tibble(fit)
  df <- tribble(
    ~name, ~slope, ~intercept,
    "days_to_previous_fb", mean(t$b_days_to_previous_fb), mean(t$b_Intercept),
    "age", mean(t$b_age), mean(t$b_Intercept),
    "weight", mean(t$b_weight), mean(t$b_Intercept)
  )
  return(df)
}
x <- map_dfr(spline_fits_list, helper, .id="group")

# This doesn't work with labeller as it assumes the function converts character vectors to character vectors.
# So, it doesn't operate on factors.
plot_labeller <- function(group){
  group <- case_when(group == "pre_menopausal_female" ~ "pre",
                     group == "post_menopausal_female" ~ "post",
                     TRUE ~ group)
  factor(group, levels=c("male", "pre", "post"))
}
plot_labeller2 <- function(group){
  fct_recode(group, pre = "pre_menopausal_female", post="post_menopausal_female")
}


line_coeffs <- map_dfr(bayesian_fits_list, helper2, .id="group") %>%
  filter(!group %in% c("all", "female")) %>%
  mutate(group = plot_labeller(group)) %>%
  mutate(intercept = 0)  # Don't use these after all for comparability with the splines
g_scaled <- x %>% 
  #mutate(group = factor(group, levels=c("male", "pre_menopausal_female", "post_menopausal_female"))) %>%
  mutate(group = plot_labeller(group)) %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), data = line_coeffs) +
  labs(title="Hb deferral, scaled", y="s(value)") +
  #lims(y=c(-10, 5)) +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE#, 
                     #labeller = labeller(group=plot_labeller)
                     )
if (save_figs) {
  filename <- sprintf("%s/splines_scaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_scaled
```

```{r Plot unscaled splines}
variable_stats2 <- variable_stats %>%
  mutate(group = case_when(
    group == "pre_menopausal_female" ~ "pre",
    group == "post_menopausal_female" ~ "post",
    TRUE  ~ group
  ))
unscaled_line_coeffs <- line_coeffs %>% 
                left_join(variable_stats2, by=c("group", "name")) %>% 
                mutate(intercept = -slope*mean/sd, slope = slope / sd)
g_unscaled <- x %>% inner_join(variable_stats, by=c("group", "name")) %>%
  mutate(value = value * sd + mean) %>%
  mutate(group = plot_labeller(group)) %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), 
              data = unscaled_line_coeffs) +
  labs(title="Hb deferral, unscaled", y="s(value)") +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE#,
                     #labeller = labeller(group=plot_labeller)
                     )
if (save_figs) {
  filename <- sprintf("%s/splines_unscaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_unscaled
```


### Effect sizes

```{r}
filename <- sprintf("%s/spline_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  spline_cis <- pretty_bayes_intervals(spline_fits_list)
  write_tsv(spline_cis, file=filename)
} else {
  spline_cis <- read_tsv(filename)
}
```


```{r}
spline_comparison_cis <- bind_rows(linear=bayes_cis, spline=spline_cis, .id="Dependency")
g <- spline_comparison_cis %>%
  mutate(Dependency = fct_recode(Dependency, `non-linear`="spline")) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  filter(Group %in% c("male", "pre_menopausal_female", "post_menopausal_female")) %>%
  mutate(Group = factor(Group, levels=c("male", "pre_menopausal_female", "post_menopausal_female"))) %>%
  mutate(across(c(Dependency, Pretty), fct_rev)) %>%
  mutate(hollow_dependency=factor(if_else(low<=1 & high>=1, NA_character_, as.character(Dependency)),
                             levels=levels(Dependency))) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Dependency, fill=hollow_dependency)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
             ) +
  geom_stripes(bayes_cis %>% filter(Variable != "femaleTRUE"), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), 
                            size=0.2
                            #linewidth=0.2
                            ) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Linear vs spline dependency", 
       x="Odds ratio", y="Standardized variables") + 
  #scale_colour_manual(values = cohort_colors) +
  facet_wrap(~Group) +
  scale_color_discrete(breaks = c("linear", "non-linear"), na.value = "NA") +
  scale_fill_discrete(guide="none", na.value = "NA") +
  # scale_colour_manual(values = cohort_colors[names(cohort_colors) != "all"],
  #                     labels = cohort_names[names(cohort_names) != "all"], na.value = NA, drop=FALSE) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal")
if (save_figs) {
  filename <- sprintf("%s/linear_vs_spline.pdf", fig_path)
  ggsave(filename=filename, plot=g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}

g
```

## Combine confidence intervals from three methods on full data.


```{r Compare confidence intervals of coefficients from two frequentist and one Bayesian method}
d <- bind_rows(freq_cis, bayes_cis %>% mutate(Method="Bayes") %>% filter(Group=="male")) %>%
  mutate(Method = ifelse(Method=="Self-made", "Normal", Method))
#  mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty))
g <- d %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Method)) + 
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Odds ratio", y="Standardized variables") 
g <- g + scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/cis_from_three_methods.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

## Odds ratios of high genetic risk versus low genetic risk

```{r, results='asis'}
compute_total_score <- function(group, data, effect_sizes) {
  v <- effect_sizes %>% 
    filter(Group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
    select(Variable, Estimate) %>% 
    mutate(Estimate = log(Estimate)) %>%
    deframe()
  #total <- dosages %>% rowwise(donor) %>% summarise(total=sum(c_across(everything())))
  weighted_sum <- data %>% mutate(total = 
                                              prs_anemia * v[["prs_anemia"]] +
                                              prs_ferritin * v[["prs_ferritin"]] +
                                              prs_hemoglobin * v[["prs_hemoglobin"]] +
                                              snp_1_169549811 * v[["snp_1_169549811"]] + 
                                              snp_6_32617727  * v[["snp_6_32617727"]]  +
                                              snp_15_45095352 * v[["snp_15_45095352"]] +
                                              snp_17_58358769 * v[["snp_17_58358769"]])
  weighted_sum
}
# Returns the lower limit for odds ratio of high genetic risk versus low genetic risk
get_odds_ratio <- function(group, limits=c(0.1, 0.9)) {
  if (length(limits) == 1)
    limits <- sort(c(limits, 1-limits))
  else stopifnot(length(limits==2) && sum(limits) == 1)
  #print(limits)
  weighted_sum <- compute_total_score(group, datas[[group]], bayes_cis)
  qs <- quantile(weighted_sum$total, limits)
  odds_ratio <- exp(qs[[2]]) / exp(qs[[1]])
  odds_ratio
}
cat(sprintf("Lower limit for odds ratio for males: %f\n", get_odds_ratio("male")))
cat(sprintf("Lower limit for odds ratio for premenopausal females: %f\n", get_odds_ratio("pre_menopausal_female")))
cat(sprintf("Lower limit for odds ratio for postmenopausal females: %f\n", get_odds_ratio("post_menopausal_female")))
# g2 <- weighted_sum %>% ggplot(aes(x=plogis(total))) + geom_histogram() 
# g2 + labs(x="Deferral probability")

# Show the variant dosage combinations of the people in the top 10% of the genetic risk
# for (group in c("male", "pre_menopausal_female", "post_menopausal_female")) {
#   cat(sprintf("*** %s ***\n", group))
#   df <- compute_total_score(group)
#   g <- df %>% ggplot(aes(x=total)) + geom_histogram() 
#   g <- g + labs(x="Total genetic score", title=group)
#   plot(g)
#   df <- df %>% 
#     filter(total >= quantile(df$total, 0.90)) %>% 
#     group_by(across(starts_with("snp_"))) %>% 
#     summarise(average_total=mean(total), n=n(), .groups="drop") %>% 
#     arrange(average_total) #%>% 
#   #rename(average_total=total)
#   #print(df)
#   print(knitr::kable(df))
# }
```

Average predictor values in each percentile.

```{r, eval=FALSE}
for (group in c("male", "pre_menopausal_female", "post_menopausal_female")) {
  df <- compute_total_score(group, datas[[group]], bayes_cis)
  # Compute the percentile to which each donor belongs to
  df2 <- df %>% 
    mutate(percentile = cut(total, 
                            breaks=quantile(total, seq(0.0, 1.0, 0.1)), 
                            labels=1:10,
                            include.lowest=TRUE)) 
    my_summarise <- function(df, func) {
      df %>%
        group_by(percentile) %>%
        summarise(across(all_of(genetic_variables), func)) %>%
        pivot_longer(cols = !percentile)
    }
    L <- list(mean=my_summarise(df2, mean), median=my_summarise(df2, median))
    g <-  bind_rows(L, .id="Method") %>%
      ggplot(aes(x=percentile, y=value, fill=name)) +
      geom_col(position="dodge") +
      GGally::geom_stripped_cols() +
      facet_grid(~Method) +
      labs(title=group) +
      theme(#legend.position="bottom",    
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
    plot(g)
  
}
```

Weighted average predictor values in each risk score decile. Weight each variable by its effect size.

```{r}
risk_score_distribution <- function(group, data, effect_sizes)  {
  # Effect sizes of genetic variables
  v <- effect_sizes %>% 
    filter(Group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
    select(Variable, Estimate) %>% 
    mutate(Estimate = log(Estimate)) %>%
    deframe()
  df <- compute_total_score(group, data, effect_sizes)
  # Compute the percentile to which each donor belongs to
  df2 <- df %>% 
    mutate(decile = cut(total, 
                            breaks=quantile(total, seq(0.0, 1.0, 0.1)), 
                            labels=1:10,
                            include.lowest=TRUE)) %>%
    mutate(across(all_of(genetic_variables), function(x) x*v[[cur_column()]]))
  df2
}  
risk_score_histogram <- function(group, data, effect_sizes)  {
  df2 <- risk_score_distribution(group, data, effect_sizes)
  my_summarise <- function(df, func) {
      df %>%
        group_by(decile) %>%
        summarise(across(all_of(genetic_variables), func)) %>%
        pivot_longer(cols = !decile)
    }
    L <- list(mean=my_summarise(df2, mean), median=my_summarise(df2, median))
    df <- bind_rows(L, .id="Method") %>%
      mutate(name = factor(name, levels=genetic_variables))
    df
}
visualize_risk_score_histogram <- function(df) {
    g <- df %>%
      ggplot(aes(x=decile, y=value, fill=name)) +
      geom_col(position="stack") +
      GGally::geom_stripped_cols() +
      facet_grid(~Method) +
      labs(title=group) +
      theme(#legend.position="bottom",    
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
    g
}
groups <- c("male", "female", "pre_menopausal_female", "post_menopausal_female")
bayes_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, datas[[group]], bayes_cis))
names(bayes_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(bayes_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_bayes_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```



### Confidence intervals

```{r}
# Returns an array of total genetic scores with rows as sampling iterations (4*500) and columns as individuals
sample_sum_scores <- function(group) {
  draws <- as_draws_array(bayesian_fits_list[[group]])
  d <- dim(draws)
  n <- d[[1]] * d[[2]]   # iterations * chains
  betas <- posterior::subset_draws(draws, 
                        variable = str_replace(genetic_variables, "^", "b_"), 
                        draw = 1:n)
  betas <- drop(unclass(betas))  # Drop redundant singleton dimension of chains, since the are merged to a single chain
  # Remove "b_" from the start of variable names
  tmp <- dimnames(betas)
  tmp$variable <- str_remove(tmp$variable, "^b_")
  dimnames(betas) <- tmp
  #betas %>% skimr::skim() %>% focus(numeric.mean, numeric.sd) %>% as_tibble() %>% print()
  covariates <- t(datas[[group]] %>% select(all_of(genetic_variables)))
  # print(attributes(betas))
  # print(attributes(covariates))
  # Check that the variable names are in same order
  stopifnot(dimnames(betas)[[2]] == dimnames(covariates)[[1]])
  weighted_sum <- betas %*% covariates
  names(dimnames(weighted_sum)) <- c("iteration", "individual")
  weighted_sum
}
# Returns an array of total genetic scores with rows as sampling iterations and columns as individuals.
# This version samples from a normal distribution.
sample_sum_scores2 <- function(group, data, effect_sizes, iterations=2000) {
  get_samples <- function(Variable, low, Estimate, high) {
    #print(c(Variable, low, Estimate, high))
    mysd <- (high-Estimate)/qnorm(0.975)   # Standard deviation
    v <- rnorm(iterations, mean=Estimate, sd=mysd)
    #print(v)
    df <- tibble({{Variable}}:=v)
    #print(df)
    return(df)
  }
  effect_sizes <- effect_sizes %>% 
    filter(Group == group, Variable %in% genetic_variables) %>%
    select(Variable, low, Estimate, high) %>%
    mutate(across(c(low, Estimate, high), log))  # Back to linear scale
  # 'iterations' rows and column for each variable
  # For some reason the pmap_dfc call didn't work
  betas <- bind_cols(pmap(effect_sizes, get_samples)) %>% 
    select(genetic_variables) %>%  # Reorder the variables
    data.matrix()                  # Convert to matrix
  #betas %>% skimr::skim() %>% skimr::focus(numeric.mean, numeric.sd) %>% as_tibble() %>% print()
  #pmap_dfc(effect_sizes, get_samples)
  covariates <- t(data %>% select(all_of(genetic_variables)))
  dimnames(betas)[[1]] <- as.character(1:iterations)
  #print(attributes(betas))
  #print(attributes(covariates))
  # Check that the variable names are in same order
  #print(dimnames(betas)[[2]])
  #print(dimnames(covariates)[[1]])
  stopifnot(dimnames(betas)[[2]] == dimnames(covariates)[[1]])
  weighted_sum <- betas %*% covariates
  #print(attributes(weighted_sum))
  names(dimnames(weighted_sum)) <- c("iteration", "individual")
  weighted_sum
}

```

```{r}
get_odds_ratio2 <- function(weighted_sum, limits=c(0.1, 0.9)) {
  if (length(limits) == 1)
    limits <- sort(c(limits, 1-limits))
  else stopifnot(length(limits==2) && sum(limits) == 1)
  qs <- quantile(weighted_sum, limits)
  odds_ratio <- exp(qs[[2]]) / exp(qs[[1]])
  odds_ratio
}
filename <- sprintf("%s/deferral_bayes_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- names(bayesian_fits_list)[2:5]
  group_names
  weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  #weighted_sum_samples <- map2(group_names, datas[group_names], sample_sum_scores2, bayes_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  bayes_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  bayes_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(bayes_genetic_risks, file=filename)
} else {
  bayes_genetic_risks <- read_tsv(filename)
}
bayes_genetic_risks
```


# Survival analysis

```{r}
cox_variables <- c("weight", 
                   #"bmi", 
                    "previous_Hb",
                   "smoking", 
                   "snp_17_58358769", "snp_6_32617727",  "snp_15_45095352", "snp_1_169549811", 
                   "prs_anemia", "prs_ferritin", "prs_hemoglobin", "donation_count" )
cox_model_variables <- c(cox_variables, "age", "status")
```

```{r}
helper <- function(df, key) {
  df2 <- df %>% filter(Hb_deferral)
  if (nrow(df2) > 0) {
    return(tibble(status=1, dateonly=first(df2$dateonly), age_at_first_attempt = min(df$age))) # age at first event
  } else {
    return(tibble(status=0, dateonly=last(df$dateonly), age_at_first_attempt = min(df$age)))   # censored
  }
}
survival_filename <- sprintf("%s/survival.rds", base)
if (recompute_survival | !file.exists(survival_filename)) {
  #library(multidplyr)  # Does not support group_modify
  #cluster <- new_cluster(4)
  sur3 <- donations %>%
    #filter(label == "train") %>%
    arrange(dateonly) %>%
    group_by(donor) %>%
    #partition(cluster) %>%
    group_modify(helper) %>%
    ungroup()
    #collect()
  saveRDS(sur3, survival_filename)
} else {
  sur3 <- readRDS(survival_filename) %>% ungroup()
}
```

```{r}
head(sur3 %>% select(-donor))
```


```{r}
# Compute age with more precision
get_dob <- function() {  # Get date of birth
  res <- raw_donors %>% select(donor=KEY_DONOR, dob=KEY_DONOR_DOB) %>% mutate(dob=lubridate::ymd(dob))
  return(res)
}
add_age <- function(df) {
  df <- left_join(df, get_dob()) %>%
    mutate(age = as.numeric((dateonly - dob) / 365.25))
}
filename <- sprintf("%s/full_survival_data.rds", base)
if (recompute | !file.exists(filename)) {
  sur <- donations %>% 
    inner_join(sur3, by=c("donor", "dateonly")) %>%
    right_join(finngen, by="donor") %>%
    full_join(dosages, by="donor") %>%
    full_join(scores, by="donor") %>%
    mutate(across(where(is.logical), as.factor))
  
  sur <- add_age(sur)
  
  cat(sprintf("Model variables are %s\n", paste(cox_model_variables, collapse=", ")))
  exclusions_deferral_cox <- sur %>% summarise(across({{cox_model_variables}}, ~ sum(is.na(.))))
  filename2 <- sprintf("%s/exclusions_deferral_cox.tsv", table_path)
  write_tsv(exclusions_deferral_cox, filename2)
  old_n <- nrow(sur); old_count2 <- ndonor(sur)
  sur <- sur %>% drop_na({{model_variables}})
  cat(sprintf("Dropping %i/%i rows (%i/%i donors) due to NA in model variables\n", old_n - nrow(sur), old_n, 
              old_count2 - ndonor(sur), old_count2))
  
  saveRDS(sur, filename)
} else {
  sur <- readRDS(filename)
}
```

```{r}
cat(sprintf("%i donors, %i events, %i censored", nrow(sur), sum(sur$status == 1), sum(sur$status == 0)))
cat(sprintf("Prevalence of Hb-deferral: %.1f%%", 100*sum(sur$status == 1) / nrow(sur)))
```




```{r}
s <- survival::Surv(sur$age, sur$status)
head(s)
```

```{r}
unscaled_sur_male <- sur %>% filter(group == "male")
unscaled_sur_female <- sur %>% filter(group != "male")
unscaled_sur_pre_menopausal_female <- sur %>% filter(group == "pre_menopausal_female")
unscaled_sur_post_menopausal_female <- sur %>% filter(group == "post_menopausal_female")
```

```{r Scale for Cox models}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("age", "status")) & ! starts_with("snp_"), myscale))
}
scaled_sur <- scale_helper(sur)
scaled_sur_male   <- scale_helper(unscaled_sur_male)
scaled_sur_female   <- scale_helper(unscaled_sur_female)
scaled_sur_pre_menopausal_female  <- scale_helper(unscaled_sur_pre_menopausal_female)
scaled_sur_post_menopausal_female <- scale_helper(unscaled_sur_post_menopausal_female)
```

Check the male data. Because the data is sorted by time, some distributions look very skewed.

```{r}
tmp <- scaled_sur_male %>% 
  select(-c(recent_deferrals, consecutive_deferrals)) %>%
  drop_na() %>% 
  mutate(smoking=as.numeric(smoking)) %>% 
  select(where(is.numeric)) %>%
  mutate(donors = ifelse(row_number() <= 1700, "old", "new")) %>%
  group_by(donors) %>% slice_sample(n=1700) %>% ungroup()

tmp %>%
#  pivot_longer(cols = everything()) %>% 
  pivot_longer(cols = -donors) %>% 
  ggplot(aes(x=value, fill=donors)) + geom_histogram(position = "dodge") + 
  facet_wrap(~name, scales = "free")
```


## Kaplan-Meier curve

```{r}
km_fit <- survival::survfit(Surv(age, status) ~ 1, data=sur)
autoplot(km_fit) + labs(x="Age", y="Survival from Hb deferral")
ggsurvplot(km_fit, palette = "#2E9FDF", conf.int = TRUE, risk.table = TRUE, risk.table.y.text.col=TRUE)
```

```{r Stratify by sex}
ggsurvplot(survival::survfit(Surv(age, status) ~ female, data=sur), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip male}
helper <- function(fun) {
  g <- ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_male), 
             fun=fun, conf.int = TRUE) 
             #risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
  g
}
g1 <- helper("event")
g2 <- helper(NULL)  # no transformation means the normal survival curve
g3 <- helper("cumhaz")
arrange_ggsurvplots(list(g1, g2, g3), ncol=1, nrow=3)
#print(g1$plot)
#print(g2$plot)
#print(g3$plot)
```


```{r Stratify by RNF43 snip female}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```


```{r Stratify by RNF43 snip premenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_pre_menopausal_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip postmenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, 
                             # There is only one homozygote with this snip
                             data=unscaled_sur_post_menopausal_female %>% filter(snp_17_58358769 != 2)), 
           conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r}
helper <- function(variable) {
  force(variable)
  form <- sprintf("Surv(age, status) ~ %s", variable)
  print(form)
  form <- as.formula(form)
  # Note! Below we need to use survminer::surv_fit instead of survival::survfit
  # To fix the following error https://github.com/kassambara/survminer/issues/252
  g <- ggsurvplot(
    #survival::survfit(form, data=sur), 
    survminer::surv_fit(form, data=sur), 
             #fun=fun, 
    legend = "right",
    legend.labs = 0:2,
    legend.title = "Dosage",
    censor = FALSE,
    conf.int = TRUE) 
             #risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
  #print("hullo")
  g + labs(title=variable, y="")
}
G <- map(snip_variables, helper)
# g1 <- helper("event")
# g2 <- helper(NULL)  # no transformation means the normal survival curve
# g3 <- helper("cumhaz")
g <- G[[1]]$plot / G[[2]]$plot / G[[3]]$plot / G[[4]]$plot + plot_layout(guides = 'collect') + 
  labs(y="Survival probability")
if (save_figs) {
  #filename <- sprintf("%s/pdf/deferral_kaplan_meyer.pdf", result_base)
  filename <- sprintf("%s/old_deferral_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g
#grid::grid.draw(grid::textGrob("Keno", x = 0.02, rot = 90))

#arrange_ggsurvplots(G, ncol=1, nrow=4)
```

```{r Better KM plots}
kaplan_meyer_helper <- function(variable, sur, smooth=FALSE) {
  smooth_helper <- function(df, key) {
    min_time <- min(df$time)
    max_time <- max(df$time)
    result <- tibble(time=seq(min_time, max_time, length.out = 100))
    for (variable2 in c("surv", "low", "high")) {
      form <- sprintf("%s ~ s(time, bs='cs')", variable2)
      form <- as.formula(form)
      
      gm <- mgcv::gam(form, data=df)
      
      result <- result %>% mutate({{variable2}} := as.vector(predict(gm, newdata=result)))
    }
    result
  }
  
  force(variable)
  form <- sprintf("Surv(age, status) ~ %s", variable)
  print(form)
  form <- as.formula(form)
  res <- survminer::surv_fit(form, data=sur)
  print(res$strata)
  df <- tibble(time=res$time, surv=res$surv, low=res$lower, high=res$upper,
               Dosage=factor(rep(0:(length(res$strata)-1), res$strata)),
               variable = variable)
  if (smooth) {
    df <- df %>% 
      group_by(Dosage, variable) %>%
      filter(n() > 15) %>%
      group_modify(smooth_helper) %>%
      ungroup() %>%
      mutate()
  }
  df
}
kaplan_meyer <- function(sur, smooth=FALSE) {
  res <- map_dfr(snip_variables, function(variable) kaplan_meyer_helper(variable, sur, smooth)) %>%
    mutate(variable = factor(variable, snip_variables)) %>%
    drop_na()
  res  
}
pretty_snips <- descript %>% filter(str_starts(Variable, "snp")) %>% select(Variable, Pretty) %>% deframe()
res <- kaplan_meyer(sur)
smoothed_res <- kaplan_meyer(sur, smooth=TRUE)
g <- res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  pammtools::geom_stepribbon(alpha=0.2, color=NA) +
  geom_step() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Age [years]", y="Survival")
smoothed_g <- smoothed_res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  geom_ribbon(alpha=0.2, color=NA) +
  geom_line() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Age [years]", y="Survival")
g
smoothed_g
if (save_figs) {
  filename <- sprintf("%s/deferral_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
  filename <- sprintf("%s/smoothed_deferral_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
```

Separate by sex.

```{r}
# Male
male_smoothed_res <- kaplan_meyer(unscaled_sur_male, smooth=TRUE)
male_smoothed_g <- male_smoothed_res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  geom_ribbon(alpha=0.2, color=NA) +
  geom_line() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Time", y="Survival", title="Male")
male_smoothed_g
# Female
female_smoothed_res <- kaplan_meyer(unscaled_sur_female, smooth=TRUE)
female_smoothed_g <- female_smoothed_res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  geom_ribbon(alpha=0.2, color=NA) +
  geom_line() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Time", y="Survival", title="Female")
female_smoothed_g
if (save_figs) {
  filename <- sprintf("%s/male_smoothed_deferral_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, male_smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
  filename <- sprintf("%s/female_smoothed_deferral_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, female_smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
```

## Cox regression

```{r Define formulas}
cox_formula <- as.formula(sprintf("Surv(age, status) ~ %s", paste(cox_variables, collapse=" + ")))
cox_formula_all <- as.formula(sprintf("Surv(age, status) ~ %s", paste(c(cox_variables, "female"), collapse=" + ")))
print(cox_formula)
print(cox_formula_all)
```

```{r}
helper <- function(sur, group) {
  cat(sprintf("Cox PH model, group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
              group,
              nrow(sur), 
              sum(sur$status == 1), 
              sum(sur$status == 0),
              100*sum(sur$status == 1) / nrow(sur)))
  
}
helper(scaled_sur, "all")
helper(scaled_sur_male, "male")
helper(scaled_sur_female, "female")
helper(scaled_sur_pre_menopausal_female, "female")
helper(scaled_sur_post_menopausal_female, "female")
#cat(sprintf("%i donors, %i events, %i censored, prevalence %.1f%%", nrow(sur), sum(sur$status == 1), sum(sur$status == 0)))
#cat(sprintf("Prevalence of Hb-deferral: %.1f%%", 100*sum(sur$status == 1) / nrow(sur)))
```

### Fit models

```{r Fit Cox models}
cox_fit_all    <- survival::coxph(cox_formula_all, data=scaled_sur)
cox_fit_male   <- survival::coxph(cox_formula,     data=scaled_sur_male)
cox_fit_female <- survival::coxph(cox_formula,     data=scaled_sur_female)
cox_fit_pre_menopausal_female  <- survival::coxph(cox_formula, data=scaled_sur_pre_menopausal_female)
cox_fit_post_menopausal_female <- survival::coxph(cox_formula, data=scaled_sur_post_menopausal_female)
cox_fit_list <- list(all=cox_fit_all, male=cox_fit_male, female=cox_fit_female,
                     pre_menopausal_female=cox_fit_pre_menopausal_female,
                     post_menopausal_female=cox_fit_post_menopausal_female)
filename <- sprintf("%s/cox_fits.rds", base)
saveRDS(cox_fit_list, filename)

```


```{r}
g <- survminer::ggsurvplot(survfit(cox_fit_male), scaled_sur_male, risk.table = TRUE)
g
```

Below, on the left are the Kaplan-Meier curves and on the right the Cox proportional hazards model. For each model the event, survival and cumulative hazard curves are shown. This is for male data. Effect of snp_17_58358769
is illustrated. On the right, the model forces the proportional hazard assumption to hold.

```{r}
# Keep other variables at zero and vary the variable snp_17_58358769
row1 <- as_tibble_row(set_names(rep(0, length(cox_variables)), cox_variables))
params <- bind_rows(row1, row1 %>% mutate(snp_17_58358769=1)) %>% 
  mutate(smoking = as.factor(smoking==1))
params
helper <- function(fun) {
  #survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), scaled_sur_male, risk.table = TRUE)
  sf <- survfit(cox_fit_male, data=scaled_sur_male)
  df <- as.data.frame(params)
  g <- survminer::ggsurvplot(survfit(cox_fit_male, newdata=df), 
                             data=df, risk.table = FALSE, fun=fun)
  g
}
g4 <- helper("event")
g5 <- helper(NULL)
g6 <- helper("cumhaz")
g <- arrange_ggsurvplots(list(g1, g2, g3, g4, g5, g6), 
                         title="Effect of SNP 17:58358769",
                         ncol=2, nrow=3)
g
```



```{r All survival, eval=FALSE}
# g <- survminer::ggforest(cox_fit_all, data = scaled_sur) 
# g
```

```{r Male survival}
# g <- survminer::ggforest(cox_fit_male, data = scaled_sur_male) 
# g
```

```{r Female survival}
# g <- survminer::ggforest(cox_fit_female, data = scaled_sur_female) 
# g
```

```{r Premenopausal female survival}
# survminer::ggforest(cox_fit_pre_menopausal_female, data = scaled_sur_pre_menopausal_female) 
```

```{r Postmenopausal female survival}
#survminer::ggforest(cox_fit_post_menopausal_female, data = scaled_sur_post_menopausal_female) 
```

### Effect sizes

```{r}
descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))

filename <- sprintf("%s/cox_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  cox_cis <- bind_rows(map(cox_fit_list, mass_cis), .id="Group") %>%
    rename(Estimate=coef) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    left_join(descript2, 
              by=c(Variable="Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    #mutate(Pretty = fct_relevel(as.factor(Pretty), myorder)) %>%
    mutate(across(c(Estimate, low, high), exp))
  write_tsv(cox_cis, file=filename)
} else {
  cox_cis <- read_tsv(filename)
}
```

```{r}

mylimits <- c(0.2, 4)
g <- cox_cis %>% 
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(cox_cis, Pretty) +
  # geom_rect(data=make_stripes(cox_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") + 
  #xlim(0.2, 10) +
  scale_x_log10(limits=mylimits) +
  scale_y_discrete() + 
  scale_colour_manual(values=cohort_colors) +
  labs(title="Cox model")
if (save_figs) {
  filename <- sprintf("%s/cox_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Odds ratios of high genetic risk (normal Cox)

```{r}
normal_cox_datas <- list(male=scaled_sur_male, female=scaled_sur_female)
groups <- c("male", "female")
normal_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, normal_cox_datas[[group]], cox_cis))
names(normal_cox_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(normal_cox_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_normal_cox_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r}
filename <- sprintf("%s/deferral_normal_cox_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- c("male", "female")
  group_names
  #weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  weighted_sum_samples <- map2(group_names, normal_cox_datas[group_names], sample_sum_scores2, cox_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  normal_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  normal_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(normal_cox_genetic_risks, file=filename)
} else {
  normal_cox_genetic_risks <- read_tsv(filename)
}
normal_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cox male)}
genetic_scores <-  compute_total_score("male", scaled_sur_male, cox_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
#sf <- survfit(cox_fit_male, data=scaled_sur_male)
g <- survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cos female)}
genetic_scores <-  compute_total_score("female", scaled_sur_female, cox_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
sf <- survfit(cox_fit_female, data=scaled_sur_female)
g <- survminer::ggsurvplot(survfit(cox_fit_female, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```


### Diagnostics

See [diagnostics](http://www.sthda.com/english/wiki/cox-model-assumptions)

#### Check for proportional hazards assumption

Test the null hypothesis that the proportional hazards assumption holds.


```{r}
extract_ph_stats <- function(fit) { # Get p-values of variables from the fit
  survival::cox.zph(fit)$table %>% as.data.frame() %>% rownames_to_column(var="variable") %>% select(variable, p)
}
res <- map_dfr(cox_fit_list, extract_ph_stats, .id="model") %>% pivot_wider(names_from = model, values_from=p)
pvalue_table(res)
#res
```

No surprise that the proportional hazards assumption does not seem to hold for donation_count as it is time-dependent variable.

Why are some plots below bipartite or tripartite? Categorical covariates can cause this. See for example
https://mwsug.org/proceedings/2006/stats/MWSUG-2006-SD08.pdf

```{r, eval=FALSE}
# Don't repeat the constant part of labels
helper <- function(g) {
  g$labels$title <- str_remove(g$labels$title, "Schoenfeld Individual ")
  g$labels$y <- str_remove(g$labels$y, "Beta\\(t\\) for ")
  g
}
schoenfeld_residuals <- function(fit, title) {
  test_ph <- cox.zph(fit)
  g <- ggcoxzph(test_ph)
  g <- map(g, helper)   # Remove the repeated texts
  # I use plot_grid instead of the default plotting method, since
  # otherwise the combined plot disappears, when zoomed.
  g2 <- cowplot::plot_grid(plotlist = g)
  annotate_figure(g2, top = text_grob(paste("Schoenfeld residuals", title, sep=" ")),
                  left = "Beta(t)")
}
schoenfeld_residuals(cox_fit_all, "all")
schoenfeld_residuals(cox_fit_male, "male")
schoenfeld_residuals(cox_fit_female, "female")
schoenfeld_residuals(cox_fit_pre_menopausal_female, "premenopausal female")
schoenfeld_residuals(cox_fit_post_menopausal_female, "postmenopausal female")

```

#### Check for outliers

It’s also possible to check outliers by visualizing the deviance residuals. The deviance residual is a normalized transform of the martingale residual. These residuals should be roughtly symmetrically distributed about zero with a standard deviation of 1.

*    Positive values correspond to individuals that “died too soon” compared to expected survival times.
*    Negative values correspond to individual that “lived too long”.
*    Very large or small values are outliers, which are poorly predicted by the model.


```{r }
s <- "linear.predictions"
ggcoxdiagnostics(cox_fit_all,    type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_male,   type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_female, type = "deviance", ox.scale = s)

# The reason for bipartite cloud can be seen better in the below plots,
# where the OX axis is the observation id. The observations are sorted
# by the event year.
s <- "observation.id"
ggcoxdiagnostics(cox_fit_all,    type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_male,   type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fit_female, type = "deviance", ox.scale = s)

```

Let's color the points by event status.

```{r}
my_residual_plot <- function(fit, data) {
  t <- "deviance"
  r <- residuals(fit, type=t)
  data <- data %>% mutate(r = r, 
                          linear_predictors = fit$linear.predictors,
                          Status = case_when(status == 0 ~ "Censored", TRUE ~ "Deferral"))
  data %>% ggplot(aes(x=linear_predictors, y=r, color=Status)) + 
    geom_hline(yintercept = 0) +
    geom_point() +
    labs(y=t)
}
m <- my_residual_plot(cox_fit_male, scaled_sur_male)
m
```


For some reason the following doesn't work:

```{r, eval=FALSE}
g <- ggcoxdiagnostics(cox_fit_all,
                 type = "schoenfeld",
                 #type = "deviance",
                 ox.scale = "time")
g
```

#### Check for linearity of predictors

```{r,eval=FALSE}
tmp_fit <- survival::coxph(Surv(age, status) ~ bmi + log(bmi) + sqrt(bmi), 
                           data = scaled_sur_male %>% drop_na(bmi))
ggcoxfunctional(tmp_fit)#, data = sur_male %>% drop_na(bmi))
```

## Survival with time-dependent covariates

```{r}
baseline_variables <- setdiff(c(cox_variables, "female"), c("donation_count", "previous_Hb"))
# Time-independent variables
tdc_variables <- c("donation_count", "previous_Hb")  # time-dependent covariates
```

```{r}


# Cut time-series at the first deferral. Number of donors stays the same
until_first_deferral <- function(df) {
  has_deferrals <- df %>% group_by(donor) %>% filter(max(Hb_deferral)==1) %>% ungroup()
  has_no_deferrals <- df %>% group_by(donor) %>% filter(max(Hb_deferral)==0) %>% ungroup()
  has_deferrals <- has_deferrals %>% 
    arrange(dateonly) %>% 
    group_by(donor) %>% 
    slice(1:min(which(Hb_deferral))) %>% 
    ungroup()
  result <- bind_rows(has_no_deferrals, has_deferrals)
  return(result %>% arrange(dateonly))
}


sex_group_df <- donations %>% select(donor, female) %>% distinct()
#don2 <- donations %>% filter(donor %in% c("0329699", "0768527"))
#don2 <- donations
don <- until_first_deferral(donations)
don <- add_age(don)
baseline <- finngen %>%
  inner_join(sex_group_df, by="donor") %>%
  inner_join(dosages, by="donor") %>%
  inner_join(scores, by="donor") %>%
  mutate(across(where(is.logical), as.factor)) %>% 
  select(all_of(c("donor", baseline_variables)))
common_donor <- intersect(unique(baseline$donor), unique(don$donor))
baseline <- baseline %>% filter(donor %in% common_donor)
don <- don %>% filter(donor %in% common_donor)
tdc <- tmerge(data1=baseline, 
              data2=don %>% group_by(donor) %>% slice_tail(n=1) %>% ungroup(),  # Last donations
              id=donor, tstop=age, status = event(age, Hb_deferral))
tdc2 <- tmerge(data1=tdc, 
               data2=don,
               id=donor, 
               donation_count=cumtdc(age, !Hb_deferral, 0),
               previous_Hb=tdc(age, Hb))
```

Does the created data look sensible?

```{r}
attr(tdc2, "tcount")
```

Looks ok. See the Value section in the help page of `survival::tmerge` for explanation of the columns.

```{r Scale for time-dependent Cox model datasets}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("tstart", "tstop", "status")) & ! starts_with("snp_"),
                       myscale))
}
tdc_scaled_all <- scale_helper(tdc2)
tdc_scaled_male <- scale_helper(tdc2 %>% filter(female == FALSE))
tdc_scaled_female <- scale_helper(tdc2 %>% filter(female == TRUE))
```


```{r Time-dependent Cox formulas}
cox_tdc_formula_all <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(c(baseline_variables, tdc_variables), collapse=" + ")))
cox_tdc_formula_male <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(setdiff(c(baseline_variables, tdc_variables), "female"),
                                            collapse=" + ")))
cox_tdc_formula_female <- cox_tdc_formula_male
cox_tdc_formula_all
cox_tdc_formula_male
```

```{r}
helper <- function(data, group) {
  tmp <- data %>% drop_na() %>% arrange(tstop) %>% group_by(donor) %>% slice_tail(n=1)
    cat(sprintf("Time-dependent covariate Cox PH model, group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
              group,
              nrow(tmp), 
              sum(tmp$status == 1), 
              sum(tmp$status == 0),
              100*sum(tmp$status == 1) / nrow(tmp)))
#cat(sprintf("There are %i individuals in time-dependent Cox PH model\n", ))
}
helper(tdc_scaled_all, "all")
helper(tdc_scaled_male, "male")
helper(tdc_scaled_female, "female")
```

### Fit models

```{r Fit Cox models with time-dependent variables}
cox_tdc_fit_all <- coxph(cox_tdc_formula_all, tdc_scaled_all)
cox_tdc_fit_male <- coxph(cox_tdc_formula_male, tdc_scaled_male)
cox_tdc_fit_female <- coxph(cox_tdc_formula_female, tdc_scaled_female)

cox_tdc_fit_list <- list(all=cox_tdc_fit_all, male=cox_tdc_fit_male, female=cox_tdc_fit_female)
filename <- sprintf("%s/cox_tdc_fits.rds", base)
#saveRDS(cox_tdc_fit_list, filename)
```



### Diagnostics

Can we discard the null hypothesis that the proportional hazards assumption holds?

```{r}
res <- map_dfr(cox_tdc_fit_list, extract_ph_stats, .id="model") %>% 
  pivot_wider(names_from = model, values_from=p)
pvalue_table(res)
```



### Effect sizes

```{r Plot time-dependent Cox model effect sizes}
descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))

filename <- sprintf("%s/cox_tdc_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  cox_tdc_cis <- bind_rows(map(cox_tdc_fit_list, mass_cis), .id="Group") %>%
    # bind_rows(all = mass_cis(cox_tdc_fit_all), 
    #                        male = mass_cis(cox_tdc_fit_male), 
    #                        female = mass_cis(cox_tdc_fit_female), 
    #                        .id="Group") %>%
    rename(Estimate=coef) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    left_join(descript2, by=c(Variable="Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(across(c(Estimate, low, high), exp))
  
  write_tsv(cox_tdc_cis, file=filename)
} else {
  cox_tdc_cis <- read_tsv(filename)
}


g <- cox_tdc_cis %>% 
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(cox_tdc_cis, Pretty) +
  # geom_rect(data=make_stripes(cox_tdc_cis, Pretty) %>% filter(stripe==1),
  #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
  #                       ymin = as.numeric(Pretty) - 0.5),
  #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10(limits = mylimits) +
  scale_y_discrete() + 
  labs(title="Time-dependent Cox model")
if (save_figs) {
  filename <- sprintf("%s/cox_tdc_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Odds ratios of high genetic risk (TDC Cox)

```{r}
tdc_cox_datas <- list(male=tdc_scaled_male %>% select(donor, all_of(genetic_variables)) %>% distinct(),
                      female=tdc_scaled_female %>% select(donor, all_of(genetic_variables)) %>% distinct())
groups <- c("male", "female")
tdc_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, tdc_cox_datas[[group]], cox_tdc_cis))
names(tdc_cox_risk_score_histograms) <- groups
for (group in groups) {
  g <- visualize_risk_score_histogram(tdc_cox_risk_score_histograms[[group]])
  plot(g)
  filename <- sprintf("%s/deferral_tdc_cox_total_score_histogram_%s.png", fig_path, group)
  if (save_figs)
    ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r Sanity check of the distributions of each genetic variable}
tdc_cox_risk_score_distributions <- map(groups, function(group) risk_score_distribution(group, tdc_cox_datas[[group]], cox_tdc_cis))
names(tdc_cox_risk_score_distributions) <- groups
helper <- function(df, label) {
  df2 <- df %>%
    pivot_longer(cols = all_of(genetic_variables)) 
  df2 %>%
    ggplot(aes(value)) +
    geom_histogram() +
    geom_vline(data = df2 %>% 
                 group_by(name, decile) %>% 
                 summarise(mean=mean(value), median=median(value), .groups = "drop") %>% 
                 pivot_longer(cols=c("mean", "median"), names_to = "method"),
               mapping = aes(xintercept=value, color=method),
               size=0.25) +
    facet_grid(name ~decile, scales = "free") +
    labs(title = sprintf("%s n=%i", label, tdc_cox_risk_score_distributions[[str_to_lower(label)]] %>% pull(donor) %>% unique() %>% length))
}
g_male <- helper(tdc_cox_risk_score_distributions$male, "Male") + theme_gray(base_size = 7)
g_female <- helper(tdc_cox_risk_score_distributions$female, "Female") + theme_gray(base_size = 7)
g_male
g_female
ggsave("/tmp/male.png", g_male, width = 180, height=90, units="mm")
ggsave("/tmp/female.png", g_female, width = 180, height=90, units="mm")
```


```{r Compute confidence intervals for genetic risk odd ratio}
filename <- sprintf("%s/deferral_tdc_cox_genetic_risks.tsv", table_path)
if (recompute | !file.exists(filename)) {
  group_names <- c("male", "female")
  group_names
  #weighted_sum_samples <- map(group_names, sample_sum_scores)
  # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
  weighted_sum_samples <- map2(group_names, tdc_cox_datas[group_names], sample_sum_scores2, cox_tdc_cis, iterations=2000)
  names(weighted_sum_samples) <- group_names
  odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
  odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
  tdc_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
  tdc_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
  write_tsv(tdc_cox_genetic_risks, file=filename)
} else {
  tdc_cox_genetic_risks <- read_tsv(filename)
}
tdc_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox male)}
genetic_scores <-  compute_total_score("male", tdc_scaled_male, cox_tdc_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
#sf <- survfit(cox_fit_male, data=scaled_sur_male)
g <- survminer::ggsurvplot(survfit(cox_tdc_fit_male, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox female)}
genetic_scores <-  compute_total_score("female", tdc_scaled_female, cox_tdc_cis)
# Which genetic variable combinations are at 1st and 9th deciles?
indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
params <- genetic_scores[indices,]
# Set non-genetic variables to zero
vars <- setdiff(cox_variables, genetic_variables)
params[, vars] <- 0
params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
params
g <- survminer::ggsurvplot(survfit(cox_tdc_fit_female, newdata=params), 
                           data=params, risk.table = FALSE, fun=NULL,
                           legend.title ="Total genetic score quantile",
                           legend.labs = c(0.1, 0.9))
g
```

# Genetic risk using different methods

```{r}
all_genetic_risks <- bind_rows(list(bayes=bayes_genetic_risks, normal_cox=normal_cox_genetic_risks, tdc_cox=tdc_cox_genetic_risks),
                               .id="method") %>% relocate(mean, .after="group")
filename <- sprintf("%s/deferral_all_genetic_risks.tsv", table_path)
write_tsv(all_genetic_risks, file=filename)
openxlsx::write.xlsx(all_genetic_risks, file = sprintf("%s/deferral_all_genetic_risks.xlsx", table_path), overwrite=TRUE)
all_genetic_risks
```

```{r}
# This is shown in the article for the TDC model
df1 <- bind_rows(bayes_risk_score_histograms, .id="group")
df2 <- bind_rows(normal_cox_risk_score_histograms, .id="group")
df3 <- bind_rows(tdc_cox_risk_score_histograms, .id="group")
deferral_genetic_risk_histograms <- bind_rows(bayes=df1, normal_cox=df2, tdc_cox=df3, .id="method") %>% rename(stat=Method)
filename <- sprintf("%s/deferral_genetic_risk_histograms.tsv", table_path)
write_tsv(deferral_genetic_risk_histograms, file=filename)

```

```{r}
helper <- function(df, stat) {
  df %>%
    filter(group %in% c("male", "female"), stat=={{stat}}) %>%
    ggplot(aes(x=decile, y=value, fill=name)) +
    geom_col(position="stack") +
    GGally::geom_stripped_cols() +
    facet_grid(group~method) +
    lims(y=c(-0.4, 0.8)) +
    labs(title={{stat}}) +
    theme(#legend.position="bottom",    
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank())
}
g1 <- helper(deferral_genetic_risk_histograms, "median")
g2 <- helper(deferral_genetic_risk_histograms, "mean")
filename1 <- sprintf("%s/deferral_all_total_score_histogram_median.png", fig_path)
filename2 <- sprintf("%s/deferral_all_total_score_histogram_mean.png", fig_path)
if (save_figs) {
  ggsave(filename=filename1, g1, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
  ggsave(filename=filename2, g2, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}  
g1
g2
```




# Bayesian survival

## brms way

The support for survival models in brms does not seem to work.

```{r Bayesian survival, eval=FALSE}
#cox_fit_male <- survival::coxph(cox_formula, data=sur_male)
bayesian_cox <- brm(cox_formula,                     
    data = sur2, 
    family = cox(),
    file = NULL,
    control = list(max_treedepth = 15),
    cores = 4,
    iter = iterations)
```

## rstanarm

Let's try rstanarm package instead.


https://cran.r-project.org/web/packages/rstanarm/index.html
Instructions for survival in rstanarm:
https://arxiv.org/abs/2002.09633

Survival models in rstanarm are still experimental and the feature is not included in the cran version. Install
it manually as described below.

```
git clone -b feature/survival https://github.com/stan-dev/rstanarm.git
R -e 'roxygen2::roxygenize("rstanarm"); devtools::install("rstanarm", build_vignettes = FALSE)'
```

The following models are not Cox models, but parameterized (M-splines) survival models with time-dependent
covariates.

```{r}
library(rstanarm)
```

```{r}
rstanarm_variables <- c("weight", 
                        "previous_Hb",
                        "smoking", 
                        "snp_17_58358769", "snp_6_32617727",  "snp_15_45095352", "snp_1_169549811", 
                        "prs_anemia", "prs_ferritin", "prs_hemoglobin", "donation_count", 
                        "female")

# Time-independent variables
tdc_variables <- c("donation_count", "previous_Hb")  # time-dependent covariates

baseline_variables <- setdiff(rstanarm_variables, tdc_variables)

rstanarm_tdc_formula_all <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(c(baseline_variables, tdc_variables), collapse=" + ")))
rstanarm_tdc_formula_male <- as.formula(sprintf("Surv(tstart, tstop, status) ~ %s", 
                                      paste(setdiff(c(baseline_variables, tdc_variables), "female"),
                                            collapse=" + ")))
rstanarm_tdc_formula_female <- rstanarm_tdc_formula_male
rstanarm_tdc_formula_all
rstanarm_tdc_formula_male
```

This broke down for some reason.

```{r Fit parameterized survival models with time-dependent variables in rstanarm, eval=FALSE}
#cox_tdc_fit_all <- coxph(cox_tdc_formula_all, tdc_scaled_all)
#cox_tdc_fit_male <- coxph(cox_tdc_formula_male, tdc_scaled_male)
#cox_tdc_fit_female <- coxph(cox_tdc_formula_female, tdc_scaled_female)

rstanarm_tdc_fit_all <- stan_surv(
  formula = cox_tdc_formula_all,
  data = tdc_scaled_all,
  chains = 4,
  cores = 4,
  seed = 123,
  iter = 1000)
#cox_tdc_fit_list <- list(all=cox_tdc_fit_all, male=cox_tdc_fit_male, female=cox_tdc_fit_female)
filename <- sprintf("%s/rstanarm_tdc_fits_all.rds", base)
#saveRDS(rstanarm_tdc_fit_all, filename)
```

```{r, eval=FALSE}
print(rstanarm_tdc_fit_all)
summary(rstanarm_tdc_fit_all)
plot(rstanarm_tdc_fit_all)
```

```{r, eval=FALSE}
# I doesn't seem to be possible to run this.
#     Error in ps_check(rstanarm_tdc_fit_all) :
#     'ps_check' cannot currently be used on models with delayed entry.
#ps_check(rstanarm_tdc_fit_all)
```

```{r, eval=FALSE}
get_rstanarm_cis <- function(fit) {
  df <- summary(fit, probs=c(0.025, 0.975), pars="beta") %>% as_tibble(rownames="Variable")
  df <- df %>% 
    filter(!str_detect(Variable, "^m-splines")) %>%
    rename(Estimate=mean, low = `2.5%`, high = `97.5%`) %>%
    mutate(across(c(Estimate, low, high), exp)) %>%
    left_join(descript2, by=c(Variable="Variable2")) %>%
    mutate(Pretty = coalesce(Pretty, Variable)) %>%
    mutate(Pretty = fct_relevel(Pretty, function(v) str_sort(v, numeric = TRUE))) %>%
    arrange(Pretty) %>%
    relocate(Pretty, Variable, Estimate, low, high)
  df
}
rstanarm_all_cis <- get_rstanarm_cis(rstanarm_tdc_fit_all)
```

```{r, eval=FALSE}

rstanarm_all_cis %>% 
  mutate(Group = "all") %>%
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_stripes(rstanarm_all_cis, Pretty) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") + 
  #xlim(0.2, 10) +
  #scale_x_log10(limits=mylimits) +
  scale_x_log10() + 
  scale_y_discrete() + 
  scale_colour_manual(values=cohort_colors) +
  labs(title="Bayesian proportional hazards model all")
```

```{r, eval=FALSE}
plot(rstanarm_tdc_fit_all, "areas", #regex_pars = "period",
     prob = 0.5, 
     prob_outer = 1.0)
```




