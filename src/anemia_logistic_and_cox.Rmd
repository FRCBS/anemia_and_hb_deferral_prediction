---
title: "Logistic regression for anemia"
author: "Jarkko Toivonen"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
#  md_document:
#    toc: yes
#    toc_depth: 3
  # pdf_document:
  #   toc: yes
  #   toc_depth: 4
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GGally)
#library(safeBinaryRegression)
library(detectseparation)  # This is better than the above package
library(brms)
library(furrr)
library(broom)
library(tidybayes)
library(bayesplot)
library(survival)
library(survminer)
library(ggfortify)
library(ggridges)
library(ggstance)
library(knitr)
library(kableExtra)
library(patchwork)
#library(tictoc)
allow_individual_level_data <- TRUE
recompute_dosages <- FALSE
recompute_survival <- FALSE
recompute <- FALSE
save_figs <- FALSE
save_tables <- FALSE
#base <- "~/FRCBS/blood_health_phewas/logistic_regression"
base <- "/home/ivm/anemia-gwas/logistic_regression"
fig_path <- sprintf("%s/figures", base)
data_path <- sprintf("%s/data", base)
table_path <- sprintf("%s/tables", base)

source("common.R")

# This can measure time a chunk took to execute.
# Add chunk option time_it=TRUE to each chunk your want to measure.
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- lubridate::now()
    } else {
      # calculate the time difference after a chunk
      res <- lubridate::now() - now
      # return a character string to show the time
      msg <- sprintf("\nTime for this code chunk to run: %f %s\n", as.numeric(res), units(res))
      message(msg)
      NULL   # Don't return the message so that it won't be printed to the resulting document.
      msg
    }
  }
}))
knitr::opts_chunk$set(echo=TRUE, time_it=TRUE)
```

# Helper functions

```{r Define prediction variables}
variables <- c("female", "age", #"year",
             "weight", 
             "smoking", #"bmi", 
             "blood_donor", 
             #"prs_anemia",
             "prs_ferritin","prs_hemoglobin",
             "snp_17_58358769", 
             "snp_6_32617727", "snp_15_45095352", "snp_1_169549811")
interactions <- c("blood_donor:weight", "blood_donor:smoking")
snip_variables <- c("snp_1_169549811", "snp_6_32617727", "snp_15_45095352", "snp_17_58358769")

#interactions <- c()
```

```{r}

#cohort_order <- c("all", "male", "pre_menopausal_female", "post_menopausal_female")

# Convert variable name in v to prettier versions
to_pretty_vector <- function(v, d) {
  tibble(Variable=v) %>% left_join(descript, by="Variable") %>% mutate(Pretty = if_else(is.na(Pretty), Variable, Pretty)) %>%
    pull(Pretty)
  # The below solution won't work if an element of v isn't found in the table d. In this case
  # I would like to leave the element unmodified
  #d %>% filter(Variable %in% v) %>% mutate(Variable = factor(Variable, levels=v)) %>% arrange(Variable) %>% pull(Pretty)
}

to_encoded <- function(d, v) {
  d %>% filter(Variable==v) %>% mutate(t = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable)) %>% pull(t)
}

# d is a variable description dataframe. 
# interactions is of form c("blood_donor:weight", "blood_donor:smoking")
# Return a dataframe where the interactions are added.
add_interaction_descriptions <- function(d, interactions, encoded=FALSE) {
  helper <- function(int) {
    ab <- str_split_fixed(int, ":", n=2)[1,]
    a <- ab[1]
    b <- ab[2]
    ap <- to_pretty_vector(a, d)
    bp <- to_pretty_vector(b, d)
    if (encoded) {
      a <- to_encoded(d, a)
      b <- to_encoded(d, b)
      name <- "Variable2"
    } else {
      name <- "Variable"
    }
    r1  <- tibble({{name}}:=sprintf("%s:%s", a, b), Type=NA, Pretty=sprintf("%s:%s", ap,bp))
    r2  <- tibble({{name}}:=sprintf("%s:%s", b, a), Type=NA, Pretty=sprintf("%s:%s", bp,ap))
    return(bind_rows(r1, r2))
  }
  df <- map_dfr(interactions, helper)
  return(df)
}

# Encode variable names
descript2 <- descript %>%
  mutate(Variable2 = to_encoded(descript, Variable)) %>%
  select(-Variable)

# Add interactions
descript2 <- bind_rows(descript2, add_interaction_descriptions(descript, interactions, encoded=TRUE))

```

```{r}
#variable_order <- c(descript$Pretty[str_starts(descript$Pretty, "SNP")], descript$Pretty[str_starts(descript$Pretty, "PRS")])
#variable_order <- NULL  # Alphabetical order
```

```{r Demographic group color palette}
# Get five equally spaced hue, and reorder so that males are blue and females are red.
# And keep this palette fixed, even if some groups are missing from some plots.
gg_color_hue <- function(n) {   # Gives 'n' equally spaced hues
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
b <- gg_color_hue(5)
cohort_colors <- c(all = b[5], male = b[4], female = b[1], pre_menopausal_female=b[2], post_menopausal_female=b[3])

```

```{r Color p-values in tables}
# Emphasize cells whose value is below the significance threshold
conditional_format <- function(c) {
  alpha <- 0.05
  cell_spec(format(c, scientific=TRUE, digits=3), 
            background = ifelse(is.na(c) | c >= alpha, "white", "red")) 
}
pvalue_table <- function(df) {
  df %>% 
    mutate(across(any_of(names(cohort_colors)), conditional_format)) %>% 
    #mutate(all = conditional_format(all)) %>% 
    kable(escape = FALSE) %>% 
    #kable(escape = FALSE, format.args = list(scientific=TRUE, digits=3)) %>% 
    kable_styling()
}
```


```{r Helper functions}


# Input is a dataframe that has a factor column whose name is given as parameter
# Returns a dataframe with two columns
# stripe column has alternating values 0 and 1
# the other column contains the levels of the specified column
make_stripes <- function(df, Variable) {
  v <- df %>% pull({{Variable}})
  if (is.factor(v)) {
    v <- levels(v)
  } else {
    v <- sort(unique(v))
  }
  tibble({{Variable}} := factor(v, levels=v)) %>% 
     mutate(stripe = row_number() %% 2)
}

geom_stripes <- function(df, Variable) {
  geom_rect(data=make_stripes(df, Variable) %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Variable) + 0.5,
                        ymin = as.numeric(Variable) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE)
}

self_made_cis <- function(fit) {
  c3 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c <- c3 %>% 
    mutate(low = Estimate - 1.96*`Std. Error`, 
           high = Estimate + 1.96*`Std. Error`) 
  return(c)
}
mass_cis <- function(fit) {   # This uses profiling based method from MASS
  c3 <- rownames_to_column(as.data.frame(confint(fit)), var="Variable") %>% as_tibble()
  c4 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c3 <- c3 %>% inner_join(c4, by="Variable")
  c <- c3 %>% 
    rename(low = `2.5 %`, high = `97.5 %`)
  return(c)
  
}

```

# Todo

* Try to bootstrap the confidence intervals. NO NEED TO. THEY'LL PROBABLY LOOK LIKE THE NORMAL CIS.
* Try multiple event per donor

# Get datas

### Get genotype data

```{r, time_it=TRUE}
if (TRUE) {
  snips <- tribble(
    ~chr, ~pos, ~ref, ~alt, ~gene,
    1, 169549811, "C", "T", "F5",
    6,  32617727, "G", "C", "HLA-DQA1",
    15,  45095352, "A", "G", "DUOX2",
    17,  58358769, "C", "T", "RNF43"
  )
} else {
  snips2 <- read_tsv("~/proj/blood_health_phewas/metaresults_finngen_R_D3_ANAEMIA_IRONDEF_lead.tsv")
  snips <- snips2 %>% 
    group_by(chrom) %>% 
    slice_min(order_by=pval) %>%   # Take snip with smallest p-value from each chromosome
    ungroup() %>% 
    slice_min(order_by=pval, n=4) %>%
    rename(chr=chrom)
}
knitr::kable(snips) %>% kable_styling()
```


The allele frequencies of UKBB are not available for R6. Check them from R8 or R9.

```{r}
helper <- function(filename) {
  cmd <- sprintf("zcat %s | 
  awk 'NR==1{print};{if ($1==1 && $2 == 169549811 || $1 == 6 && $2 == 32617727 || $1 == 15 && $2 == 45095352 || $1 == 17 && $2 == 58358769) print}'", filename)
  #print(cmd)
  result <- system(cmd, intern = TRUE)
  read_tsv(I(result))
}
vars <- c("#CHR", "POS", "REF", "ALT", "FINNGEN_beta", "FINNGEN_sebeta",  "FINNGEN_pval", "FINNGEN_af_alt", "UKBB_beta", "UKBB_sebeta", "UKBB_pval", "UKBB_af_alt", "rsid")
meta_r8 <- helper("/finngen/library-green/finngen_R8/finngen_R8_analysis_data/ukbb_meta/meta/D3_ANAEMIA_IRONDEF_meta_out.tsv.gz")
meta_r9 <- helper("/finngen/library-green/finngen_R9/finngen_R9_analysis_data/ukbb_meta/meta/D3_ANAEMIA_IRONDEF_meta_out.tsv.gz")
meta <- bind_rows(r8=meta_r8, r9=meta_r9, .id="Release")
meta %>% select(all_of(vars), Release)
meta_r8 %>% select(all_of(vars))
meta_r9 %>% select(all_of(vars))
```


```{r Create dosages}
get_snip <- function(chr, pos) {
  cat(sprintf("Chromosome %i pos %i", chr, pos))
  #dir <- "/home/toivoja/data/private/finngen"
  #filename <- sprintf("%s/finngen_R4_bb_chr%i_BLOOD_SERVICE_extracted_*_donor.vcf.gz", dir, chr) # R4
  #filename <- Sys.glob(filename)  # Expand the wildcard '*'
  #filename <- sprintf("%s/R5/BB_finngen_R7_chr%i_BLOOD_SERVICE_BB_extracted_consentdonors.vcf.gz", dir, chr) # R5
  filename <- sprintf("/finngen/library-red/finngen_R6/genotype_1.0/data/finngen_R6_chr%i.vcf.gz", chr) # R5
  result_filename <- sprintf("/tmp/poista-%i.tsv", chr)
  cmd <- sprintf("bcftools query -f 'chr\tpos\t[%%SAMPLE\t]\n%%CHROM\t%%POS\t[%%TGT\t]\n' %s -r chr%i:%i > %s",
                 filename,
                 chr,
                 pos,
                 result_filename)
  print(cmd)
  system(cmd)
  df <- read_tsv(result_filename)
  df <- df %>% mutate(chr=as.numeric(str_remove(chr, "chr")))
  df <- df[-ncol(df)]  # Drop the empty last column
  return(df)
}

#dosages_filename <- "~/proj/blood_health_phewas/R4_dosages.tsv"
dosages_filename <- sprintf("%s/R6_dosages.tsv", data_path)
if (recompute_dosages | !file.exists(dosages_filename)) {
  plan(multisession, workers = 4)
  dosages <- snips %>% 
    select(chr, pos) %>% 
    future_pmap_dfr(function(chr, pos) get_snip(chr, pos), .options = furrr_options(seed = 123)) %>%
    pivot_longer(cols=-c(chr, pos), names_to = "donor", values_to = "genotype") %>%
    inner_join(snips) %>% 
    mutate(dosage=str_count(genotype, alt)) %>%
    pivot_wider(values_from = dosage, names_from=c(chr, pos), names_prefix="snp_", id_cols = donor)
  write_tsv(dosages, dosages_filename)
} else {
  dosages <- read_tsv(dosages_filename)
}
```

```{r}
# This snip seems to have its major and minor alleles in wrong way
dosages <- dosages %>% mutate(snp_15_45095352 = 2-snp_15_45095352)
```

Do the dosages look sane? Yes.

```{r}
summary(dosages %>% mutate(across(-donor, as.factor)))
```

### PRS

```{r Get anemia weights}
anemia_weights <- read_tsv("/finngen/red/toivoja/prs/D3_ANAEMIA_IRONDEF.weights.txt", col_names = FALSE)
summary(anemia_weights)
g <- anemia_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Anemia weight")
g
```

```{r Get ferritin weights, eval=FALSE}
ferritin_weights <- read_tsv("~/proj/blood_health_phewas/prs/IronhomeostasisFerritinAllInterval_IasterDX_2018-11-06.wInfo.cl.txt.weights.txt", col_names = FALSE)
summary(ferritin_weights)
g <- ferritin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Ferritin weight")
g
```

```{r Get hemoglobin weights, eval=FALSE}
hemoglobin_weights <- read_tsv("~/proj/blood_health_phewas/prs/32888494-GCST90002384-EFO_0004509.h.tsv.weights.txt", col_names = FALSE)
summary(hemoglobin_weights)
g <- hemoglobin_weights %>% ggplot(aes(x=X6)) + geom_histogram() + scale_y_log10() + labs(x="Hemoglobin weight")
g
```

```{r Get PRS scores, results='hide', message=FALSE}
get_scores <- function(phenotype) { 
  #filenames <- sprintf("~/proj/blood_health_phewas/prs/R4_chr%i.profile", 1:22)
  filenames <- sprintf("/finngen/red/toivoja/prs/%s_scores/R6_%s_%i.profile", phenotype, phenotype, 1:22)
  names(filenames) <- sprintf("chr%i", 1:22)
  df <- map_dfr(filenames, 
                function(filename) {
                  read_table(filename, col_types = cols()) %>% select(donor=IID, {{phenotype}}:=SCORE)
                }, 
                .id="chr")
  scores <- df %>% group_by(donor) %>% summarise(across({{phenotype}}, sum))
  return(scores)
}
filename <- sprintf("%s/scores.rds", base)
if (recompute | !file.exists(filename)) {
  anemia_scores <- get_scores("anemia") %>% rename(prs_anemia = anemia)
  ferritin_scores <- get_scores("ferritin") %>% rename(prs_ferritin=ferritin)
  hemoglobin_scores <- get_scores("hb") %>% rename(prs_hemoglobin=hb)
  scores <- anemia_scores %>% inner_join(ferritin_scores) %>% inner_join(hemoglobin_scores)
  saveRDS(scores, filename)
} else {
  scores <- readRDS(filename)
}

```

```{r}
check_normality <- function(scores, variable, pretty) {
  g1 <- scores %>% 
    ggplot(aes(x=.data[[variable]])) + 
    geom_histogram() + 
    labs(x=pretty)
  g1
  g2 <- ggqqplot(scores[[variable]]) + labs(y=pretty)
  set.seed(42)
  # Null hypothesis is that the sample is normally distributed
  s <- shapiro.test(sample(scores[[variable]], 5000)) # For some reason the sample size must be between 3 and 5000
  g1+g2 + plot_annotation(title=sprintf("Shapiro-Wilk p-value: %f", s$p.value))
}
check_normality(scores, "prs_anemia", "PRS anemia")
check_normality(scores, "prs_ferritin", "PRS ferritin")
check_normality(scores, "prs_hemoglobin", "PRS hemoglobin")
```

```{r Example plot of PRS bottom and top deciles, eval=FALSE}
# This is for presentation
g <- scores %>% 
  ggplot(aes(x=prs_anemia)) + 
  geom_histogram() + 
  geom_vline(xintercept = quantile(scores$prs_anemia, c(0.1, 0.9)), color="red") +
  labs(x="PRS anemia")
if (save_figs) {
  filename <- sprintf("%s/anemia_prs.png", fig_path)
  ggsave(filename=filename,  width = 90,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}
g
```


### Get Finngen

#### Anemia event

```{r Get endpoint age}
# D3_ANAEMIA_IRONDEF
# D3_ANAEMIA_IRONDEF_AGE
# D3_ANAEMIA_IRONDEF_YEAR
# D3_ANAEMIA_IRONDEF_NEVT

endpoint_filename <- "/finngen/library-red/finngen_R6/phenotype_2.0/data/finngen_R6_phenotype_endpoint_2.1"
anemia_endpoint_filename <- sprintf("%s/anemia_endpoint.tsv", data_path)
df <- read_tsv(endpoint_filename, n_max = 0)  # Get just the column names
# And get the corresponding indices
indices <- which(colnames(df) %in% c("FINNGENID", "D3_ANAEMIA_IRONDEF", "D3_ANAEMIA_IRONDEF_AGE", 
                                     "D3_ANAEMIA_IRONDEF_YEAR", "D3_ANAEMIA_IRONDEF_NEVT"))
if (!file.exists(anemia_endpoint_filename)) {
  cmd <- sprintf("cut -f%s %s > %s", paste(indices, collapse=","),
                 endpoint_filename, anemia_endpoint_filename)
  print(cmd)
  system(cmd)
}
anemia_endpoint <- read_tsv(anemia_endpoint_filename)
```


```{r Load FinnGen data}

get_finngen <-function() {
  fg <- read_tsv(sprintf("%s/data/pheno-covar.txt", base))
  fg <- fg %>% select(donor=FINNGENID, height=HEIGHT, weight=WEIGHT, sex=SEX, smoking=SMOKE2,
                      bmi=BMI, anemia=D3_ANAEMIA_IRONDEF, AGE_AT_DEATH_OR_NOW)
  return(fg)
}
finngen <- get_finngen()
# Fix the age so that it is the age now or at first event
joined <- left_join(finngen, anemia_endpoint, by=c(donor="FINNGENID"))
# Why are the ages different between AGE_AT_DEATH_OR_NOW and D3_ANAEMIA_IRONDEF_AGE even when anemia has not occurred?
# Apparently, if an endpoint has not occurred, the endpoint_age is FU_END_AGE.
# Visualize this difference
joined %>% mutate(diff=D3_ANAEMIA_IRONDEF_AGE-AGE_AT_DEATH_OR_NOW, 
                  anemia = as.character(anemia)) %>%
  ggplot(aes(x=diff, color=anemia)) + 
  geom_freqpoly() +
  scale_y_log10()

# Starting from R7 the variable is called AGE_AT_DEATH_OR_END_OF_FOLLOWUP instead of
# AGE_AT_DEATH_OR_NOW
finngen <- joined %>% 
  mutate(age = ifelse(anemia==1, D3_ANAEMIA_IRONDEF_AGE, AGE_AT_DEATH_OR_NOW)) %>%
  select(!any_of(c("D3_ANAEMIA_IRONDEF", "D3_ANAEMIA_IRONDEF_NEVT")) & ! any_of("AGE_AT_DEATH_OR_NOW"))

#old_n <- nrow(finngen)
finngen <- finngen %>% 
  #drop_na(any_of(variables)) %>%
  mutate(smoking = as.logical(smoking),
         anemia = as.logical(anemia),
         sex = as.factor(sex),
         female = sex == "female") %>%
  mutate(group = factor(case_when(!female ~ "male",
                                  female & age < 45 ~ "pre_menopausal_female",
                                  female & age >= 45 ~ "post_menopausal_female")))
#cat(sprintf("Dropping %i/%i rows due to NA in metadata variables\n", old_n - nrow(finngen), old_n))

#  mutate(bmi = weight / (height / 100)**2,
#         smoking=ifelse(smoking %in% c("yes, occassionally", "yes, regularly"), TRUE, FALSE))
```

### Get blood donor status



```{r Get blood donor ids}
donations <- read_csv(sprintf("%s/../saige/DF1-6_VPU_no_dups.txt", base),
                      col_names = "donor")
donations$blood_donor <- TRUE
```




```{r Donation summary}
summary(donations)
```


```{r Data sizes}
cat(sprintf("Donations has %i donors\n", nrow(donations)))
cat(sprintf("Dosages has %i donors\n", nrow(dosages)))
cat(sprintf("Scores has %i donors\n", nrow(scores)))
cat(sprintf("Finngen has %i donors\n", nrow(finngen)))
cat(sprintf("Intersection has %i donors\n", length(intersect(intersect(dosages$donor, scores$donor), finngen$donor))))
```


```{r Dataset intersections}
set <- list(eProgesa = donations$donor, dosages=dosages$donor, scores=scores$donor, finngen=finngen$donor)
upset <- UpSetR::upset(UpSetR::fromList(set), order.by = "freq", nintersects = NA)
upset
```


### Combine all datas


```{r Train_validate_test split}
tvt_ratios <- c(train=0.64, validate=0.16, test=0.20)

# Can be used to split data set to train, validate, and test parts in given fraction.
# Adds column 'label' which is either a string 'train', 'validate', or 'test'
split_set3 <- function(df, seed, prob=tvt_ratios, donor_field = "KEY_DONOR") {
  message("In function split_set3")
  set.seed(seed)
  donors <- unique(df[[donor_field]])
  n <- length(donors)
  if (FALSE) {
    labels <- sample(factor(c("train", "validate", "test"), levels = c("train", "validate", "test")),
                     size=n, replace = TRUE, prob=prob)
  } else {
    n1 <- as.integer(prob[1] * n)
    n2 <- as.integer(prob[2] * n)
    n3 <- n - n1 - n2
    labels <- c(rep("train", n1), rep("validate", n2), rep("test", n3))
    labels <- factor(sample(labels, size = n), levels=c("train", "validate", "test"))  # permute
  }
  classes <- tibble({{donor_field}} := donors,
                    label=labels)
  return(inner_join(df, classes))
}
```


```{r Combine datas}
filename <- sprintf("%s/unfiltered_combined_data.rds", data_path)
if (recompute | !file.exists(filename)) {
  unfiltered_combined_data <- finngen %>%
    full_join(dosages) %>%
    full_join(scores) %>%
    left_join(donations) %>%
    replace_na(list(blood_donor=FALSE))

  
  unfiltered_combined_data <- split_set3(unfiltered_combined_data, seed=42, donor_field = "donor")
  saveRDS(unfiltered_combined_data, filename)
} else {
  unfiltered_combined_data <- readRDS(filename)
}
summary(unfiltered_combined_data %>% mutate(across(starts_with("snp_"), as.factor)))

```

```{r}
check_anemia <- function(data) {
  t2 <- table(data %>% select(anemia, blood_donor)) 
  print(t2)
  t <-  t2 %>% as_tibble %>% 
    mutate(across(c(anemia, blood_donor), as.logical))
  tf <- t %>% group_by(blood_donor) %>%
    mutate(freq = 100 * n / sum(n)) %>%
    ungroup() %>%
    filter(anemia)
  cat(sprintf("Anemia among blood donors %.4f%%\n", tf %>% filter(blood_donor) %>% pull(freq)))
  cat(sprintf("Anemia among non blood donors %.4f%%\n", tf %>% filter(!blood_donor) %>% pull(freq)))
  cat(sprintf("Anemia among all FinnGen participants %.4f%%\n", mean(data$anemia, na.rm=TRUE)*100))
}
check_anemia(unfiltered_combined_data)
```

```{r Drop missing values}
model_variables <- c("anemia", variables)
variables_to_drop <- c("nb_donat_progesa", "nb_donat_outside", "donation_count",   "first_event", "female",
                       "consecutive_deferrals", "Hb_first", "previous_Hb_def", "height", 
                       "bmi"
                       #"weight"
                       )
cat(sprintf("Model variables are %s\n", paste(model_variables, collapse=", ")))
# Set NA as age of under 18 individuals
exclusions_anemia_logistic <- unfiltered_combined_data %>% 
  mutate(age = if_else(age < 18, NA_real_, age)) %>%
  summarise(across({{model_variables}}, ~ sum(is.na(.))))
filename <- sprintf("%s/exclusions_anemia_logistic.tsv", table_path)
if (save_tables) {
  write_tsv(exclusions_anemia_logistic, filename)
}
t(exclusions_anemia_logistic)

old_n <- nrow(unfiltered_combined_data)
combined_data <- unfiltered_combined_data %>% 
  mutate(age = if_else(age < 18, NA_real_, age)) %>%
  drop_na({{model_variables}})
cat(sprintf("Dropping %i/%i rows due to NA in model variables\n", old_n - nrow(combined_data), old_n))
```


```{r}
check_anemia(combined_data)
```

```{r}
combined_data %>% 
  group_by(blood_donor, group) %>% 
  summarise(anemia = mean(anemia), .groups="drop") %>%
  pivot_wider(names_from = group, values_from=anemia)
```

The prevalence of IDA is highest in the group of premenopausal females.

Absolute IDA counts:

```{r}
combined_data %>% 
  group_by(blood_donor, group) %>% 
  summarise(anemia = sum(anemia), .groups="drop") %>%
  pivot_wider(names_from = group, values_from=anemia)
```

```{r}
combined_data %>% filter(anemia) %>% count(blood_donor)
```

Better combined table:

```{r}
blood_donor_options <- c("both", "yes", "no")
group_options <- c("all", "male", "pre_menopausal_female", "post_menopausal_female")
helper <- function(df, group_opt, blood_donor_opt) {
  stopifnot( blood_donor_opt %in% blood_donor_options)
  stopifnot( group_opt %in% group_options)
  if (blood_donor_opt == "yes")
    df <- df %>% filter(blood_donor)
  else if ( blood_donor_opt == "no")
    df <- df %>% filter(!blood_donor)
  if (group_opt != "all")
    df <- df %>% filter(group==group_opt)
  n <- nrow(df)
  cases <- sum(df$anemia)
  controls <- n - cases
  prevalence <- 100 * cases / n
  tibble(group=group_opt, blood_donor=blood_donor_opt, 
         n=n, cases=cases, controls=controls, `prevalence (%)`=prevalence)
}
#helper(combined_data, blood_donor="both", group="all")
anemia_stats <- expand_grid(group=group_options, blood_donor=blood_donor_options)
anemia_stats <- anemia_stats %>% pmap_dfr(function(group, blood_donor) helper(combined_data, group, blood_donor))
print(anemia_stats, n=Inf)
filename <- sprintf("%s/anemia_stats.tsv", table_path)
write_tsv(anemia_stats, filename)
```


```{r Count non-adults}
young_combined_data <- unfiltered_combined_data %>% filter(age < 18)
cat(sprintf("%i individuals had age below 18 of age\n", nrow(young_combined_data)))
```

```{r}
#check_anemia(combined_data)
```

```{r}
g <- combined_data %>% 
  filter(anemia) %>%
  select(D3_ANAEMIA_IRONDEF_AGE, D3_ANAEMIA_IRONDEF_YEAR) %>%
  pivot_longer(cols=everything()) %>%
  ggplot(aes(value)) +
  geom_histogram(bins = 25) +
  facet_wrap(~ name, scales = "free") +
  labs(title="Occurred IDA events")
g
if (save_figs) {
  filename <- sprintf("%s/occurred_ida_events.png", fig_path)
  ggsave(filename=filename, g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
```

```{r Summary of all donors}
summary(combined_data %>% mutate(across(starts_with("snp_"), as.factor)))
```

```{r Summary plots of all donors, eval=FALSE}
tmp2 <- combined_data %>% 
  mutate(across(where(is.logical), as.integer)) %>%
  select(where(is.numeric)) %>% 
  pivot_longer(cols = everything(), names_to = "Variable" ) %>% 
  inner_join(descript %>% mutate(Variable = str_replace_all(Variable, "`", "")), 
             by="Variable")
  

g2 <- tmp2 %>% 
  mutate(Pretty = as.factor(Pretty)) %>% 
  ggplot(aes(value)) + 
  geom_histogram() + 
  facet_wrap(. ~ Pretty, scales = "free", ncol = 4) +
  scale_y_continuous(breaks=scales::extended_breaks(n=3))
if (save_figs) {
  filename <- sprintf("%s/variable_summary.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g2
```



```{r Summaries of stratified data}
for (g in c("male", "pre_menopausal_female", "post_menopausal_female")) {
  cat(sprintf("\n*** Group %s ***\n\n", g))
  if (g == "pre_menopausal_female" && !allow_individual_level_data) {
    allowed_levels <- 0:1
  } else {
    allowed_levels <- 0:2
  }
  print(summary(combined_data %>% 
                  filter(group == {{g}}) %>% 
                  filter(snp_17_58358769 %in% allowed_levels) %>%
                  mutate(across(starts_with("snp_"), as.factor))))
}
```

### Histograms of variables

#### Histograms

```{r}
# Converts column names of a dataframe 'df' to pretty format using dataframe 'description'.
to_pretty <- function(df, description) {
  old_names <- colnames(df)
  conversion <- description %>% filter(Variable %in% old_names) %>% select(Pretty, Variable) %>% deframe()
  #print(conversion)
    #message(sprintf("descript names: %s\n", paste(description$Variable, collapse=" ")))
  #message(sprintf("old_names: %s\n", paste(old_names, collapse=" ")))
  #message(sprintf("new_names: %s\n", paste(new_names, collapse=" ")))
  df %>% rename(!!!conversion)
}
double_summary_plotter <- function(male_df, female_df, variable_descriptions, geom = "freqpoly", breaks=waiver(), ncol=NULL) {
  df <- bind_rows(male=male_df, female=female_df, .id="Sex")
  #print(df, 5)
  df <- df %>%
    mutate(across(where(is.logical), as.integer)) %>%
    #keep(is.numeric(col) %>%
    select(where(is.numeric) | Sex) %>%
    to_pretty(variable_descriptions) %>%
    #gather() %>%
    pivot_longer(!Sex) #%>%
    #mutate(name = factor(name, levels=variable_descriptions$Pretty))   # Don't sort alphabetically
  
  #if (df %>% filter(name=="Days to previous full blood donation") %>% nrow() > 0) {
  # Abbreviate this long variable name
  if ("Days to previous full blood donation" %in% levels(df$name)) {
    df <- df %>%
      mutate(name = fct_recode(name, `Days to previous FB donation`="Days to previous full blood donation"))
  }
  
  if (geom=="freqpoly") {
    g <- df %>%
      ggplot(aes(value, color=Sex)) +
      facet_wrap(~ name, scales = "free", ncol=ncol) +
      geom_freqpoly() +
      scale_x_continuous(breaks=breaks)
  } else if (geom=="histogram") {
    g <- df %>%
      ggplot(aes(value, fill=Sex)) +
      facet_wrap(~ name, scales = "free", ncol=ncol) +
      geom_histogram(position="dodge") +
      scale_x_continuous(breaks=breaks)
  } else if (geom=="hollow_histogram") {
    g <- df %>%
      ggplot(aes(value, color=Sex)) +
      facet_wrap(~ name, scales = "free", ncol=ncol) +
      geom_histogram(fill=NA, position="stack") +
      scale_x_continuous(breaks=breaks)
  } else {
    stop(sprintf("Unknow value for the geom parameter: %s", geom))
  }

  return(g)
}

```


```{r}
#source("~/FRCBS/Hb_predictor_container/src/common.R")
#base <- "~/FRCBS/blood_health_phewas/logistic_regression/"
#last_donations <- readRDS(sprintf("%s/last_donations.rds", base))
male <- combined_data %>% filter(!female) %>% select(-any_of(variables_to_drop))
female <- combined_data %>% filter(female) %>% select(-any_of(variables_to_drop))
g <- double_summary_plotter(male, female, descript, geom="hollow_histogram", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 6)
        )
if (save_figs)
  ggsave(paste(fig_path, "anemia_histogram.pdf", sep="/"), g, width = 180, units="mm")
g
```




```{r}
double_summary_plotter_case_control <- function(df, variable_descriptions, geom = "freqpoly", breaks=waiver(), ncol=NULL) {
  #df <- bind_rows(case=case_df, control=control_df, .id="Status")
  #print(df, 5)
  df <- df %>%
    mutate(across(where(is.logical), as.integer)) %>%
    #keep(is.numeric(col) %>%
    select(where(is.numeric) | c("Status", "sex")) %>%
    to_pretty(variable_descriptions) %>%
    #gather() %>%
    pivot_longer(!c("Status", "Sex")) #%>%
    #mutate(name = factor(name, levels=variable_descriptions$Pretty))   # Don't sort alphabetically
  

  if (geom=="freqpoly") {
    g <- df %>%
      ggplot(aes(value, color=Status)) +
      facet_wrap(~ name, scales = "free", ncol=ncol) +
      geom_freqpoly() +
      scale_x_continuous(breaks=breaks)
  } else if (geom=="histogram") {
    g <- df %>%
      ggplot(aes(value, fill=Sex)) +
      ggh4x::facet_grid2(rows=vars(name), cols=vars(Status), scales = "free", independent = TRUE) + 
      #facet_wrap(~ name, scales = "free", ncol=ncol) +
      geom_histogram(position="identity", alpha=0.8) +
      scale_x_continuous(breaks=breaks)
  } else if (geom=="hollow_histogram") {
    g <- df %>%
      ggplot(aes(value, color=Sex)) +
      #facet_grid(name ~ Status, scales = "free") +
      ggh4x::facet_grid2(rows=vars(name), cols=vars(Status), scales = "free", independent = TRUE) + 
      geom_histogram(fill=NA) +
      scale_x_continuous(breaks=breaks)
  } else if (geom=="bar") {
    g <- df %>%
      mutate(value = factor(value, levels=0:2),
             name = fct_relevel(name, function(v) str_sort(v, numeric=TRUE))) %>%
      ggplot(aes(value, fill=Sex)) +
      #facet_grid(name ~ Status, scales = "free") +
      ggh4x::facet_grid2(rows=vars(name), cols=vars(Status), scales = "free", independent = TRUE) + 
      geom_bar(position="dodge", width=0.5)# +
      #scale_x_discrete(breaks=breaks)
  } else {
    stop(sprintf("Unknow value for the geom parameter: %s", geom))
  }

  return(g)
}

```

```{r}
# Function to to unify x axis ranges on each row of the facetted plot.
# Returns a list of scales that can be passed as a parameter to the ggh4x::facetted_pos_scales function,
# to modify individual panels in a facetted plot
unify_range_by_rows <- function(g) {
  b <- ggplot_build(g)
  L <- length(b$layout$panel_scales_x)
  cols <- 2  # Where is this information stored? Now I have to handcode the number of columns.
  rows <- L / cols
  # Unify ranges of a single facet row
  unify <- function(r2) {
    left <- map_dbl(r2, function(x) x[[1]])  # Left ends of the ranges
    right <- map_dbl(r2, function(x) x[[2]])  # Right ends of the ranges
    u <- c(min(left), max(right))
    u <- rep(list(u), length(left))  # Repeat the same range for each column
    # Change this so that a list is returned
    u
  }
  # Extract limits from each panel
  L <- list()
  for (i in seq(1, rows)) {
    tmp <- b$layout$panel_scales_x
    r <- tmp[seq((i-1)*cols + 1, i*cols)]
    r2 <- map(r, function(x) x$range$range) # each item is numeric vector of length two
    res <- unify(r2)
    L <- append(L, res)
  }
  scales <- map(L, function(r) scale_x_continuous(limits = r))  # Turn list of ranges into a list of scales
  scales
}
```

```{r}
all <- combined_data %>% 
  select(-any_of(variables_to_drop)) %>%
  mutate(#sex = fct_recode(gender, male="Men", female="Women"),
         Status = factor(case_when(anemia ~ "case",
                            TRUE        ~ "control")) ) #%>%
  #select(sex, Status, age, hour)
categorical_variables <- c(#"Hb_deferral", 
                "smoking", #"warm_season",
                "blood_donor",
                "snp_1_169549811", "snp_6_32617727", "snp_15_45095352", "snp_17_58358769",
                "Status", "sex")
continuous_variables <- c("age",      "weight",
                #"Hb",  
 #"days_to_previous_fb",                  "previous_Hb",        
 #"year",                "hour",                "recent_donations",    "recent_deferrals",   
#"prs_anemia",        
"prs_ferritin",        "prs_hemoglobin")
all_variables <- c(categorical_variables, continuous_variables)
```


```{r}
g1 <- double_summary_plotter_case_control(all %>% select(c("Status", "sex"), all_of(categorical_variables)), 
                                          descript, geom="bar", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        )
g2 <- double_summary_plotter_case_control(all %>% select(c("Status", "sex"), all_of(continuous_variables)), 
                                          descript, geom="histogram", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        )
# Unifying the scales is simpler for discrete variables
#scales1 <- unify_range_by_rows(g1)
#gg1 <- g1 + ggh4x::facetted_pos_scales(scales1)
gg1 <- g1 + scale_x_discrete(limits=factor(0:2))

scales2 <- unify_range_by_rows(g2)
gg2 <- g2 + ggh4x::facetted_pos_scales(scales2)

if (save_figs) {
  ggsave(paste(fig_path, "anemia_histogram_case_control1.pdf", sep="/"), gg1, width = 180, units="mm")
  ggsave(paste(fig_path, "anemia_histogram_case_control2.pdf", sep="/"), gg2, width = 180, units="mm")
}

gg1
gg2
```


Avoid bins with count smaller that 5, by uniting smaller adjacent bins. The result
will be a variable width histogram.

```{r}
mybreaks <- function(x, number_of_breaks) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(number_of_breaks) != 1L)
    stop("Length of breaks must be one")
  if (is.na(number_of_breaks) || number_of_breaks < 2L) 
     stop("invalid number of intervals")
  nb <- as.integer(number_of_breaks + 1)
  dx <- diff(rx <- range(x, na.rm = TRUE))
  if (dx == 0) {
    dx <- if (rx[1L] != 0) 
      abs(rx[1L])
    else 1
    breaks <- seq.int(rx[1L] - dx/1000, rx[2L] + dx/1000, 
                      length.out = nb)
  }
  else {
    breaks <- seq.int(rx[1L], rx[2L], length.out = nb)
    breaks[c(1L, nb)] <- c(rx[1L] - dx/1000, rx[2L] + 
                             dx/1000)
  }
  breaks
}
mycut <- function(x, number_of_breaks=30) {
  breaks <- mybreaks(x, number_of_breaks)
  #x <- cut(x, breaks=breaks)
  df <- cut(x, breaks = breaks) %>% 
    table() %>% as_tibble() %>% rename(bin=".") %>% 
    mutate(low = breaks[1:number_of_breaks], high = breaks[2:(number_of_breaks+1)])
  df
}
```

```{r}
unite_small_bins <- function(df, limit=5) {
  i <- which.min(df$n)  # Unite the smallest bin
  #print(i)
  while (df[[i, "n"]] < limit) {
    #cat(sprintf("i=%i, class(i)=%s\n", i, class(i)))
    n <- nrow(df)
    i2 <-               # with this neighbouring bin
      if (i==1) 2 else {
        if (i==n) n-1 else {
          if (df[[i-1, "n"]] < df[[i+1, "n"]]) { 
            i-1 
          } else {
            i+1
          }
        }
      }
    first <- min(i, i2)
    second <- max(i, i2)
    cat(sprintf("Combining rows %i and %i from a tibble with %i rows\n", first, second, n))
    df[[first, "n"]] <- df[[first, "n"]] + df[[second, "n"]] 
    df[[first, "high"]] <- df[[second, "high"]] 
    df <- df[-second,]
    i <- which.min(df$n)  # Unite the smallest bin
    #print(i)
    #df <- unite_small_bins(df, limit)
  }
  return(df)
}
```

```{r eval=FALSE}
# Test the variable width historam with a single variable
df <- mycut(all$weight, 30)
df <- unite_small_bins(df)
g <- df %>% ggplot(aes(xmin=low, xmax=high, ymin=0, ymax=n)) + geom_rect()
g
```

```{r}
helper <- function(data, key) {
  cat(sprintf("Got dataframe with %i rows and %i columns\n", nrow(data), ncol(data)))
  df <- mycut(data$value, 30)
  df <- unite_small_bins(df)
  df
}
df <- all %>% 
  select(c("Status", "sex"), all_of(continuous_variables)) %>% 
  pivot_longer(cols=-c(Status, sex)) %>% 
  group_by(Status, sex, name)
df2 <- df %>% group_modify(helper)
```

Try to reproduce the above continuous variable histogram using geom_rect.

```{r}
g <- df2 %>% 
  mutate(name = to_pretty_vector(name, descript)) %>%
  ggplot(aes(xmin=low, xmax=high, ymin=0, ymax=n, fill=sex)) +
  geom_rect(alpha=0.8) + 
  labs(x="value", y="count", fill="Sex") +
  ggh4x::facet_grid2(name ~ Status, scales="free", independent = TRUE)
#facet_grid(name ~ Status, scales="free")
scales2 <- unify_range_by_rows(g2)
g2 <- g + ggh4x::facetted_pos_scales(scales2)

if (save_figs) {
  filename <- paste(fig_path, "anemia_histogram_case_control2_var_width.pdf", sep="/")
  ggsave(filename, g2, width = 180, units="mm")
}
g2
# Check that bin sizes (column ymax) are at least five.
g2_data <- layer_data(g2) %>% as_tibble() %>% arrange(ymax)
if (save_tables) {
  filename <- paste(table_path, "anemia_histogram_case_control2_var_width.tsv", sep="/")
  write_tsv(g2_data, filename)
}
```

```{r eval=FALSE}
# a test using the data extracted from a ggplot object
df <- layer_data(gg2) %>% as_tibble() %>% 
  rename(panel=PANEL) %>%
  mutate(group = as.factor(group))
df %>% ggplot(aes(#x=x, y=y, 
                  xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=group)) +
  geom_rect(alpha=0.8) + facet_wrap(~ panel, scales="free")
```

#### Table one

```{r}
x <- tableone::CreateTableOne(data=all %>% drop_na(-D3_ANAEMIA_IRONDEF_YEAR), vars = all_variables, factorVars = categorical_variables,
                    #argsExact = list(workspace = 10^9), # Even this wasn't large enough when stratifying by both sex and status
               strata = c("Status", "sex"), 
               addOverall = TRUE
               )
print(x, 
      showAllLevels = TRUE,
      nonnormal = setdiff(continuous_variables, c("prs_anemia", "prs_ferritin", "prs_hemoglobin"))) # Because the distributions are skewed
      #exact = setdiff(categorical_variables, c("warm_season", "smoking", "Status", "sex"))
m <- print(x,
           showAllLevels = TRUE,
           nonnormal = setdiff(continuous_variables, c("prs_anemia", "prs_ferritin", "prs_hemoglobin")), # Because the distributions are skewed
           printToggle = FALSE, noSpaces = TRUE           
) %>% as_tibble(rownames="Variable")
if (save_tables) {
  filename <- paste(table_path, "anemia_tableone.tsv", sep="/")
  write_tsv(m, filename)
}
```

#### Genotype distributions 

```{r, results='asis'}
tmp <- map_dfr(snip_variables, 
              function(snp) { 
                as_tibble(table(
              combined_data %>% 
                    select(all_of(snp), anemia)
                )) %>% 
                  pivot_longer(cols=all_of(snp))
              }
  )
genotype_distribution <- tmp %>% 
  pivot_wider(names_from = anemia, values_from = n) %>%
  rename(case=`TRUE`, control=`FALSE`) %>% 
  group_by(name) %>% 
  mutate(case_freq = case / sum(case),
         control_freq = control / sum(control)) %>%
  ungroup() %>%
  mutate(value = as.integer(value)) %>%
  rename(variable=name, dosage=value)
filename <- sprintf("%s/anemia_genotype_distribution.tsv", table_path)
if (save_tables) {
  write_tsv(genotype_distribution, filename)
}
kable(genotype_distribution, format="html", digits=2)
#genotype_distribution
```

```{r}
g <- genotype_distribution %>% 
  pivot_longer(cols=c(case_freq, control_freq), values_to = "frequency", names_to = "status") %>% 
  mutate(status = str_replace(status, "_freq", ""),
         variable = factor(variable, snip_variables)) %>%
  ggplot(aes(x=dosage, y=frequency, fill=status)) +
  geom_col(position="dodge") +
  facet_grid(~variable)
g
if (save_figs) {
   filename <- sprintf("%s/anemia_genotype_distributions.png", fig_path)
   ggsave(filename=filename,  width = 90,  height=90, units="mm", dpi=300, scale=1.0, device="png")
}
```

### Scale data



```{r Scale data}
myscale <- function(v) { return((v - mean(v, na.rm = TRUE)) / sd(v, na.rm = TRUE))}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !starts_with("snp_"), myscale))
}
data <- scale_helper(combined_data) 
data_male   <- combined_data %>% filter(group == "male") %>% scale_helper()
data_female <- combined_data %>% filter(group != "male") %>% scale_helper()
data_pre_menopausal_female  <- combined_data %>% filter(group == "pre_menopausal_female") %>% scale_helper()
data_post_menopausal_female <- combined_data %>% filter(group == "post_menopausal_female") %>% scale_helper()
datas <- list(all=data, male = data_male, female = data_female,
              pre_menopausal_female=data_pre_menopausal_female,
              post_menopausal_female=data_post_menopausal_female)

# Drop non-blood donors
#datas <- map(datas, function(df) df %>% filter(blood_donor==TRUE))

# Perform rank-based inverse normal transform on the PRS variables
inv_transform <- function(df) {
  df <- df %>%
    mutate(across(c("prs_anemia", "prs_ferritin", "prs_hemoglobin"), RNOmni::RankNorm, k=0.5))
  df
}
#datas <- map(datas, inv_transform)
```

```{r Get normalizing constants for each variable}
stat_helper <- function(df) {
  df %>% summarise(across(where(is.numeric) & ! starts_with("snp_"), 
                          list(mean=~mean(.x, na.rm=TRUE), 
                               sd=~sd(.x, na.rm=TRUE))))
}
stat_helper2 <- function(df) { # long form version
  df %>%
    select(where(is.numeric) & ! starts_with("snp_")) %>% 
    pivot_longer(cols=everything()) %>%
    group_by(name) %>% 
    summarise(mean=mean(value, na.rm=TRUE), sd=sd(value, na.rm=TRUE))
}
# For some reason this didn't work!
# variable_stats <- map_dfr(
#   list(stat_helper(last_donations %>% filter(group=="male")),
#        stat_helper(last_donations %>% filter(group=="pre_menopausal_female"))),
#   stat_helper)
dfall <- stat_helper2(combined_data)
dfm <- stat_helper2(combined_data %>% filter(group=="male"))
dfpre <- stat_helper2(combined_data %>% filter(group=="pre_menopausal_female"))
dfpost <- stat_helper2(combined_data %>% filter(group=="post_menopausal_female"))
variable_stats <- bind_rows(all=dfall, male=dfm, pre_menopausal_female=dfpre, post_menopausal_female=dfpost, .id="group")
rm(dfall, dfm, dfpre, dfpost)
```

# Logistic regression

## Frequentist logistic regression

### Fit the models


```{r}
freq_formula_all <- as.formula(sprintf("anemia ~ %s", paste(variables, collapse=" + ")))
freq_formula <- as.formula(sprintf("anemia ~ %s", paste(setdiff(variables, "female"), collapse=" + ")))
print(freq_formula_all)
print(freq_formula)
```


```{r Detect for separation, eval=FALSE}
# 'safeBinaryRegression' package sucks, I now use 'detectseparation' instead!
fit <- stats::glm(freq_formula_all,
#fit <- safeBinaryRegression::glm(my_formula,
             #data = tmp, # For safeBinaryRegression
             data = data,
             method="detect_separation",
             family = "binomial")
fit
```

No separation detected. Lets fit the model.

```{r, eval=FALSE}
filename <- sprintf("%s/fit.rds", base)
if (recompute | !file.exists(filename)) {
  #tmp <- data %>% slice_sample(n=500) %>% mutate(across(where(is.logical), as.numeric))
  fit <- stats::glm(freq_formula_all,
             data = data,
             family = binomial)
  saveRDS(fit, filename)
} else {
  fit <- readRDS(filename)
}
```

```{r Fit all frequentist models}
formulas <- list(all=freq_formula_all, male = freq_formula,  female = freq_formula, 
                 pre_menopausal_female=freq_formula,
                 post_menopausal_female=freq_formula)
freq_fits <- map2(datas, formulas, function(data, formula) stats::glm(formula, data = data, family = binomial))
```



If safeBinaryRegression was used, it complained that all variables were causing separation among the sample points.
I disabled the package.

```{r}
summary(freq_fits$all)
```

Compute the Nagelkerke R2 values for all frequentist models

```{r}
freq_nagelkerke_r2 <- map_dfr(freq_fits, function(fit) {
  fmsb::NagelkerkeR2(fit) %>% as_tibble_row()}, 
  .id="Model"
)
freq_nagelkerke_r2
```

### Diagnostics

#### Residuals

Residual deviance is significantly smaller than null deviance so the predictors offer significant information.
The median of deviance residuals is not very close to zero, which means there could be a small bias. The distribution of residuals should
be approximately normal: [What do the residuals in a logistic regression mean](https://stats.stackexchange.com/questions/1432/what-do-the-residuals-in-a-logistic-regression-mean)

```{r Plot the deviance residuals}
tmp <- combined_data %>% drop_na(any_of(variables)) %>% mutate(residual=residuals(freq_fits$all)) 
tmp %>% mutate(high_residual = residual > 1) %>% select(anemia, high_residual) %>% table()
tmp %>% ggplot(aes(x=residual)) + geom_histogram() + labs(title = "All")
```

The residual seems to be high for anemic persons and low for non-anemic persons.

```{r Plot the deviance residuals in males}
tmp <-combined_data %>% filter(sex=="male") %>% drop_na(any_of(variables)) %>% mutate(residual=residuals(freq_fits$male))
tmp %>% mutate(high_residual = residual > 1) %>% select(anemia, high_residual) %>% table()
tmp %>% ggplot(aes(x=residual)) + geom_histogram() + labs(title = "Males")
```

For explanation of deviance see:

* [Interpreting Residual and Null Deviance in GLM R](https://stats.stackexchange.com/questions/108995/interpreting-residual-and-null-deviance-in-glm-r)
* [Interpreting Generalized Linear Models](https://www.datascienceblog.net/post/machine-learning/interpreting_generalized_linear_models/)

```{r Pretty logistic formula}
# This is for presentation purposes
pretty_variables <- descript %>% filter(Variable %in% variables) %>% pull(Pretty)
cat(sprintf("anemia ~ %s", paste(pretty_variables, collapse=" + ")))
```

```{r Diagnostic plots for linear model, eval=FALSE}
plot(fit, which=c(1,2,3,4,5))
```
One should not use the above plots to interpret results of logistic regression according to 
https://stats.stackexchange.com/questions/234998/logistic-regression-diagnostic-plots-in-r

The advise on page http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/
is to check for

* linearity
* influential points using Cook's distance (above plot showed no influential points)
* multicollinearity using Variance inflation factors


#### Check for linearity


```{r}
probabilities <- predict(freq_fits$all, type = "response")
data2 <- data %>% 
  drop_na(any_of(variables)) %>% 
  select(all_of(variables)) %>% 
  select(where(is_double)) %>% 
  mutate(logit=log(probabilities/(1-probabilities)))
```

```{r Relation between each predictor with the logit scale response, eval=FALSE}
filename <- sprintf("%s/linearity_check.png", fig_path)
if (recompute | !file.exists(filename)) {
  g <- data2 %>%
    slice_sample(n=1000) %>% # Take sample to avoid time and memory problems
    pivot_longer(cols = -logit, names_to = "predictor") %>%
    ggplot(aes(logit, value))+
    geom_point(size = 0.5, alpha = 0.5) +
    geom_smooth(method = "loess") + 
    theme_bw() + 
    facet_wrap(~predictor, scales = "free_y")
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  knitr::include_graphics(filename)
}

```

All variables except maybe consecutive_deferrals and recent_deferrals seem to be linearly related to the logit scale response.

#### Check for multicollinearity

```{r Check for multicollinearity}
vifs <- map_dfr(freq_fits, function(fit) as_tibble_row(car::vif(fit)), .id="Cohort")
sorted_column_names <- vifs %>% select(-Cohort) %>% summarise(across(everything(), mean)) %>% unlist() %>% sort(decreasing = TRUE) %>% names()
# Columns sorted by mean value
vifs <- vifs %>% select(Cohort, all_of(sorted_column_names))
freq_vifs <- t(vifs %>% column_to_rownames("Cohort")) %>% as_tibble(rownames="Variable")
  #as.data.frame %>% rownames_to_column("Variable")
freq_vifs
filename <- sprintf("%s/anemia_vifs.tsv", table_path)
if (save_tables) {
  write_tsv(freq_vifs, filename)
}
```
According to https://www.statisticshowto.com/variance-inflation-factor/
VIF value greater than 5 means that it is highly correlated with other predictors.
So, it seems that weight and bmi are correlated, of course. 

The below figure is slow to compute. Let's take a small sample.

```{r Correlation between variables, eval=FALSE}
# Function to return points and geom_smooth
# allow for the method to be changed
my_fn <- function(data, mapping, method="loess", ...){
      p <- ggplot(data = data, mapping = mapping) + 
      geom_point() + 
      geom_smooth(method=method, ...)
      p
    }
g <- ggpairs(data2 %>% select(!logit & !starts_with("snp_")) %>% slice_sample(n=1000), 
             lower = list(continuous = my_fn))
if (save_figs) {
  filename <- sprintf("%s/correlations.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```


```{r}
c <- data %>% 
  #select(all_of(variables), prs_anemia) %>%    # PRS IDA is added even though it is not a predictor. On purpose.
  select(all_of(variables)) %>% 
  set_names(as.character(to_pretty_vector(names(.), descript))) %>%
  cor()
mynames <- str_sort(colnames(c), numeric=TRUE)
c <- c[mynames, mynames]    # Use alphabetical order for rows and columns
c2 <- c %>% as_tibble(rownames = "Phenotype")
c2
filename <- sprintf("%s/anemia_correlations.tsv", table_path)
if (save_tables) write_tsv(c2, filename)

filename <- sprintf("%s/anemia_correlations.pdf", fig_path)
if (save_figs) cairo_pdf(filename)
corrplot::corrplot(c)
if (save_figs) dev.off()
```

### IDA PRS as predictor

```{r}
freq_formula_all2 <- as.formula(sprintf("anemia ~ %s", paste(c(variables, "prs_anemia"), collapse=" + ")))
freq_formula2 <- as.formula(sprintf("anemia ~ %s", paste(setdiff(c(variables, "prs_anemia"), "female"), collapse=" + ")))
formulas2 <- list(all=freq_formula_all2, male = freq_formula2,  female = freq_formula2, 
                 pre_menopausal_female=freq_formula2,
                 post_menopausal_female=freq_formula2)
freq_fits2 <- map2(datas, formulas2, function(data, formula) stats::glm(formula, data = data, family = binomial))

fit2 <- freq_fits2$all
```

```{r}
#fit2
summary(fit2)
```

```{r}
glue::glue("The Nagelkerke R2 value is {format(R2, digits=3)}, sample size is {N}", 
           .envir=fmsb::NagelkerkeR2(fit2))
```

```{r Plot the deviance residuals in model with anemia prs}
tmp <-combined_data %>% drop_na(any_of(variables)) %>% mutate(residual=residuals(fit2))
tmp %>% mutate(high_residual = residual > 1) %>% select(anemia, high_residual) %>% table()
tmp %>% ggplot(aes(x=residual)) + geom_histogram() + labs(title = "Males")
```

```{r}
df <- broom::tidy(fit2, conf.int=TRUE, exponentiate=TRUE)
if (save_tables) {
  filename <- sprintf("%s/anemia_cis_with_anemia_prs_predictor.tsv", table_path)
  write_tsv(df, filename)
}
```

```{r}
g <- df %>% ggplot(aes(y=term, xmin=conf.low, xmax=conf.high, x=estimate)) +
  geom_pointinterval()
g
if (save_figs) {
  filename <- sprintf("%s/anemia_cis_with_anemia_prs_predictor.png", fig_path)
  ggsave(filename=filename, g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
```

So, the model is really overfitting a lot.

```{r}
freq_nagelkerke_r2_with_ida_prs <- map_dfr(freq_fits2, function(fit) {
  fmsb::NagelkerkeR2(fit) %>% as_tibble_row()}, 
  .id="Model"
)
freq_nagelkerke_r2_with_ida_prs
```

Much better explanation of variation than without PRS IDA.

#### Try the same with Hmisc

```{r}
fit_lrm <- rms::lrm(freq_formula_all2,
             data = data)
```

```{r}
fit_lrm
# Broom doesn't really work for rms::lrm !!!!

#df <- broom::tidy(fit2, conf.int=TRUE, exponentiate=TRUE)
#g <- df %>% ggplot(aes(y=term, xmin=conf.low, xmax=conf.high, x=estimate)) +
#  geom_pointinterval()
```

```{r}
cat(sprintf("The Nagerkerke R2 is %f\n", fit_lrm$stats["R2"]))
```

The resulting R2 is the same as with glm and fmbs::NagelkerkeR2, so no point
in running rms::lrm.

### Effect sizes

The profiling method of MASS and my simple approximation seem to produce same results.
Next, check if bootstrapping would change this.


```{r Coefficients and confidence intervals}

filename <- sprintf("%s/anemia_freq_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  res <- map(freq_fits, function(fit) mass_cis(fit))
  freq_cis <- 
    bind_rows(res, .id="Group") %>%
    left_join(descript2, 
              by=c(Variable="Variable2")) %>%
    filter(Variable != "(Intercept)") %>%
    droplevels() %>%
    mutate(across(c(Estimate, low, high), exp)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty))
  write_tsv(freq_cis, file=filename)
} else {
  freq_cis <- read_tsv(filename)
}
  
```


```{r}

g <- freq_cis %>% 
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_rect(data=make_stripes(freq_cis, "Pretty") %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                        ymin = as.numeric(Pretty) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, 
            colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(title="Frequentist", x="Odds ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale

  theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
if (save_figs) {
  filename <- sprintf("%s/anemia_freq_cis.png", fig_path)
  ggsave(filename=filename, g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Models with interactions

```{r Define frequentist interaction models}
freq_int_formula_all <- as.formula(sprintf("anemia ~ %s", paste(c(variables, interactions), collapse=" + ")))
freq_int_formula <- as.formula(sprintf("anemia ~ %s", paste(setdiff(c(variables, interactions), "female"), collapse=" + ")))
freq_int_formula_all
freq_int_formula
```

```{r Fit frequentist interaction models}
interaction_formulas <- list(all=freq_int_formula_all, male = freq_int_formula, female = freq_int_formula,
                             pre_menopausal_female=freq_int_formula,
                             post_menopausal_female=freq_int_formula)
freq_int_fits <- map2(datas, interaction_formulas, function(data, formula) stats::glm(formula, data = data, family = binomial))
```

```{r Coefficients and confidence intervals of frequentist interaction models}

filename <- sprintf("%s/anemia_freq_int_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  res <- map(freq_int_fits, function(fit) mass_cis(fit))
  freq_int_cis <- 
    bind_rows(res, .id="Group") %>%
    left_join(descript2, 
              by=c(Variable="Variable2")) %>%
    filter(Variable != "(Intercept)") %>%
    droplevels() %>%
    mutate(across(c(Estimate, low, high), exp)) %>%
    mutate(Group = factor(Group, names(cohort_colors))) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) #%>%
  write_tsv(freq_int_cis, file=filename)
} else {
  freq_int_cis <- read_tsv(filename)
}
```


```{r}

g <- freq_int_cis %>% 
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=fct_rev(Pretty), color=fct_rev(Group))) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_rect(data=make_stripes(freq_int_cis, "Pretty") %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                        ymin = as.numeric(Pretty) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, 
            colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(title="Frequentist with interactions", x="Odds ratio", y="Standardized variables", color = "Group") + 
  scale_x_log10() +
  scale_colour_manual(values = cohort_colors) +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())

if (save_figs) {
  filename <- sprintf("%s/anemia_freq_int_cis.png", fig_path)
  ggsave(filename=filename, g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Model for blood donors only

```{r}
freq_formula_all_bd <- as.formula(sprintf("anemia ~ %s", paste(setdiff(variables, "blood_donor"), collapse=" + ")))
freq_formula_bd <- as.formula(sprintf("anemia ~ %s", paste(setdiff(variables, c("female", "blood_donor")), collapse=" + ")))
# There is a separation problem in males
freq_formula_bd_male <- as.formula(sprintf("anemia ~ %s", paste(setdiff(variables, c("female", "blood_donor", "snp_1_169549811")), collapse=" + ")))

print(freq_formula_all_bd)
print(freq_formula_bd)
print(freq_formula_bd_male)
```


```{r Check for separation in frequentist models on blood donors}
# models_bd <- list(all=freq_formula_all, male = freq_formula,  female = freq_formula, 
#                  pre_menopausal_female=freq_formula,
#                  post_menopausal_female=freq_formula)
model_bd <- tribble(
  ~group, ~formula,
  "all", freq_formula_all_bd,
  "male", freq_formula_bd_male,
  "female", freq_formula_bd,
  "pre_menopausal_female", freq_formula_bd,
  "post_menopausal_female", freq_formula_bd
) %>%
  inner_join(enframe(datas, name="group", value="data")) %>%
  mutate(data = map(data, . %>% filter(blood_donor)))
model_bd <- model_bd %>%
  mutate(
    detect_separation = pmap(., function(group, data, formula) {
      stats::glm(formula,
                 data = data,
                 method="detect_separation",
                 family = "binomial")
    })
  )
```


```{r Display separation results in frequentist models on blood donors}
model_bd <- model_bd %>%  
  mutate(separation = map_lgl(detect_separation, function(d) d$separation))
model_bd %>%
  select(group, separation)
```

The male model seem to be fully separable. Show the problematic variables:

```{r}
x <- model_bd %>% filter(separation) %>%
  mutate(effects = map(detect_separation, function(d) d$coefficients))
x$effects
```

```{r}
model_bd %>%
  pwalk(function(group, data, ...) {
    cat(sprintf("Logistic regression, group: %s, n %i, cases %i, controls %i, prevalence %.1f%%\n",
                group,
                nrow(data),
                sum(data$anemia),
                sum(!data$anemia),
                mean(data$anemia)*100))
  })
```

```{r Fit all frequentist models on blood donors}
model_bd <- model_bd %>%
  mutate(
    fit = pmap(., function(group, data, formula, ...) {
      stats::glm(formula, data = data, family = binomial)
    })
  )


r2 <- model_bd %>% 
  select(group, fit) %>% 
  deframe() %>%
  map_dfr(function(fit) {
    fmsb::NagelkerkeR2(fit) %>% as_tibble_row()}, 
    .id="group"
  )
model_bd <- model_bd %>% inner_join(r2)
model_bd %>% select(-c("formula", "data", "detect_separation", "fit"))
```

```{r}
df <- model_bd %>% 
  select(group, fit) %>% 
  deframe() %>% 
  map_dfr(tidy, exponentiate=TRUE, conf.int=TRUE, .id="group") 
freq_bd_cis <- df %>%
  filter(term != "(Intercept)") %>%
  rename(Group = group, Variable=term, Estimate=estimate, low=conf.low, high=conf.high) %>%
  mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
  mutate(Pretty = to_pretty_vector(Variable, descript2),
         Pretty = fct_relevel(Pretty, ~ str_sort(., numeric=TRUE))) %>%
  arrange(Pretty)
if (save_tables) {
  filename <- sprintf("%s/anemia_freq_bd_cis.tsv", table_path)
  write_tsv(freq_bd_cis, filename)
}
```

```{r}
g <- freq_bd_cis %>% 
  filter(Group %in% c("male", "pre_menopausal_female", "post_menopausal_female")) %>%
  #filter(!(Group == "male" & Variable == "snp_1_169549811")) %>% # This is huge! Separation problem!
  mutate(across(c(Pretty, Group), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_rect(data=make_stripes(freq_bd_cis, "Pretty") %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                        ymin = as.numeric(Pretty) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, 
            colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(title="Frequentist IDA (blood donors)", x="Odds ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors, breaks=c("male", "pre_menopausal_female", "post_menopausal_female")) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale

  theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
if (save_figs) {
  filename <- sprintf("%s/anemia_freq_bd_cis.png", fig_path)
  ggsave(filename=filename, g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

## Bayesian logistic regression



```{r}

iterations <- 10000
cores <- 4
#bayesian_variables <- setdiff(variables, "female")
#bayes_variables <- variables
bayes_variables <- c(variables, interactions)
bayes_formula <- as.formula(sprintf("anemia ~ %s", 
                                    paste(setdiff(bayes_variables, "female"), collapse=" + ")))
print(bayes_formula)
bayes_formula_all <- as.formula(sprintf("anemia ~ %s", paste(bayes_variables, collapse=" + ")))
print(bayes_formula_all)

```

Flat prior is used for every parameter except the Intercept and sigma are student_t distributed.

```{r Show the used priors, eval=FALSE}
get_prior(bayes_formula, data_male)
```

```{r}
for (group in names(datas)) {
  tmp <- datas[[group]]
  cat(sprintf("Logistic regression, group: %s, n %i, cases %i, controls %i, prevalence %.1f%%\n",
              group,
              nrow(tmp),
              sum(tmp$anemia),
              sum(!tmp$anemia),
              mean(tmp$anemia)*100))
}
```

### Fit the models

```{r, eval=FALSE}
# For temporary use only
#xhelper <- function(bayesian_fit, group) {
#  filename <- sprintf("%s/noia_nobd_yes17_noinv/bayesian_fit_%s.rds", data_path, group)
#  #print(filename)
#  #print(bayesian_fit)
#  saveRDS(bayesian_fit, filename)
#}
```


```{r Run all Bayesian models at once}
fit_bayesian_helper <- function(group, data, formula) {
  #filename <- sprintf("%s/noia_nobd_yes17_noinv/bayesian_fit_%s.rds", data_path, group)
  filename <- sprintf("%s/bayesian_fit_%s.rds", data_path, group)
  if (recompute | !file.exists(filename)) {
    if (FALSE & group=="male") {
      control <- list(max_treedepth = 15, adapt_delta = 0.999)
      iterations2 <- 10000
    } else  {
      control <- list(max_treedepth = 15)
      iterations2 <- iterations
    }
    bayesian_fit <- brm(formula,
                            data = data, 
                            family = bernoulli(),
                            file = NULL,
                            control = control,
                            refresh = 0,
                            cores = cores,
                            iter = iterations2
    )
    saveRDS(bayesian_fit, filename)
  } else {
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
bayesian_input <- tibble(group=c("all", "male", "female", "pre_menopausal_female", "post_menopausal_female"),
                         data=datas,
                         formula = c(bayes_formula_all, bayes_formula, bayes_formula, bayes_formula, bayes_formula))
#bayesian_formulas <- list(all=bayes_formula_all, male = bayes_formula, pre_menopausal_female=bayes_formula,
#                 post_menopausal_female=bayes_formula)
bayesian_fits <- pmap_dfr(bayesian_input, fit_bayesian_helper)  # Call fit_bayesian_helper for each tibble row
bayesian_fits_list <- deframe(bayesian_fits)

```

```{r}
bayesian_fits
```


### Diagnostics

#### Trace {.tabset}

```{r}
#mcmc_plot(bayesian_fit, type = "trace", n_warmup = 500)
# Include the warmup iterations for comparison
helper <- function(group, fit) {
  bp <- bayesplot::mcmc_trace(as_draws_array(fit, inc_warmup = TRUE), n_warmup = iterations/2)
  if (save_figs) {
    filename <- sprintf("%s/traces_%s.png", fig_path, group)
    ggsave(filename=filename,  plot=bp, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  bp
}
traces <- pmap(bayesian_fits, helper)
names(traces) <- bayesian_fits$group
```

##### All

```{r}
traces$all
```

##### Male

```{r}
traces$male
```

##### Female

```{r}
traces$female
```

##### Premenopausal female

```{r}
traces$pre_menopausal_female
```

##### Postmenopausal female

```{r}
traces$post_menopausal_female
```

#### Auto-correlation {.tabset}

Is there something wrong with this? No, one just needs to zoom it!

```{r}
acs <- pmap(bayesian_fits, ~ mcmc_plot(.y, type = "acf_bar") + labs(title=.x))
names(acs) <- bayesian_fits$group
```

##### All

```{r}
acs$all
```

##### Male

```{r}
acs$male
```

##### Female

```{r}
acs$female
```

##### Premenopausal female

```{r}
acs$pre_menopausal_female
```

##### Postmenopausal female

```{r}
acs$post_menopausal_female
```

#### Rhat {.tabset}

Check Rhats to see if we converged.

```{r}
helper <- function(group, fit) {
  mcmc_plot(fit, type = "rhat") + labs(title=group)
}
rhats <- pmap(bayesian_fits, ~ mcmc_plot(.y, type = "rhat") + labs(title=.x))
names(rhats) <- bayesian_fits$group
```

##### All

```{r}
rhats$all
```

##### Male

```{r}
rhats$male
```

##### Female

```{r}
rhats$female
```

##### Premenopausal female

```{r}
rhats$pre_menopausal_female
```

##### Postmenopausal female

```{r}
rhats$post_menopausal_female
```


We reached convergence.

#### Distributions {.tabset}

```{r , message=FALSE, warning=FALSE}

extract_variables_names <- function(fit) {
  a <- as.array(fit)
  v <- attr(a, "dimnames")$variable
  return(setdiff(v, c("b_Intercept", "lp__")))
}
forest_plot <- function(fit, id) {
  bvariables <- extract_variables_names(fit)
  p <- mcmc_plot(fit, 
                 type = "areas",
                 prob = 0.95,
                 variable = bvariables,
                 area_method = "equal area",
                 transformations = "exp"
  ) +
    geom_vline(xintercept = 1, color = "grey") +
    labs(x="Odds ratio") + 
    scale_x_log10()
  if (save_figs) {
    filename <- sprintf("%s/bayesian_area_plots_%s.png", fig_path, id)
    ggsave(filename=filename,  plot=p, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  p
}

# This self-made version has pretty labels unlike the previous function
forest_plot2 <- function(fit, id) {
  #bvariables = if (id=="all") bvariables else setdiff(bvariables, "b_femaleTRUE")
  bvariables <- extract_variables_names(fit)
  a <- as.array(fit, variable=bvariables)
  tmp <- mcmc_areas_data(a, 
                         prob = 0.95,
                         area_method = "equal area",
                         #variable = variables2,
                         transformations = "exp"
  )
  
  tmp2 <- tmp %>% 
    filter(parameter != "exp(b_intercept)") %>% 
    mutate(Variable2 = str_match(parameter, "exp\\(b_(.*)\\)")[,2]) %>%
    left_join(descript2, by="Variable2") %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable2, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty))
  g2 <- tmp2 %>% 
    mutate(Pretty = fct_rev(Pretty)) %>%
    filter(interval == "inner") %>% 
    #filter(str_detect(parameter, r"(exp\(b_.*\))")) %>% 
    ggplot(aes(x=x, y=Pretty, height=plotting_density)) + 
    geom_ridgeline(scale=0.9) +
    geom_ridgeline(mapping=aes(x=x, y=Pretty, height=plotting_density), 
                   data=tmp2 %>% filter(interval=="outer"), 
                   fill=NA, scale=0.9) +
    scale_y_discrete() +
    labs(x="Odds ratio", y="Variable") +
    scale_x_log10()
}

```

##### All

```{r}
g <- forest_plot2(bayesian_fits_list$all, "all")
g
```

##### Male

```{r}
g <- forest_plot2(bayesian_fits_list$male, "male")
g
```

##### Female

```{r}
g2 <- forest_plot2(bayesian_fits_list$female, "female")
g2
```

##### Premenopausal female

```{r}
g <- forest_plot2(bayesian_fits_list$pre_menopausal_female, "pre_menopausal_female")
g
```

##### Postmenopausal female

```{r}
g <- forest_plot2(bayesian_fits_list$post_menopausal_female, "post_menopausal_female")
g
```

### Effect sizes


```{r Extract confidence interals from Bayesian fit}
get_bayes_intervals <- function(bayesian_fit) {
  bayes_cis <- mcmc_intervals_data(as_draws_array(bayesian_fit), 
                                   point_est="mean", regex_pars = "^b_.*", prob = 0, prob_outer = 0.95)
  bayes_cis <- bayes_cis %>% 
    rename(Variable=parameter, Estimate=m, low=ll, high=hh) %>%
    mutate(Variable = str_remove(Variable, "b_")) %>%
    mutate(Variable = if_else(Variable=="Intercept", "(Intercept)", Variable)) %>%
    select(Variable, low, Estimate, high)
  return(bayes_cis)
}
pretty_bayes_intervals <- function(bayesian_fits_list) {
  map_dfr(bayesian_fits_list, get_bayes_intervals, .id="Group") %>%
    left_join(descript2, by=c(Variable = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    filter(Variable != "(Intercept)") %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors))) %>%
    mutate(across(c(Estimate, low, high), exp))
}
```

```{r}
filename <- sprintf("%s/anemia_bayes_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  bayes_cis <- pretty_bayes_intervals(bayesian_fits_list)
  
  write_tsv(bayes_cis, file=filename)
} else {
  bayes_cis <- read_tsv(filename)
}
```

```{r Compare confidence intervals of Bayesian method on four strata}
helper <- function(df) {
  g <- df %>% 
    #filter(!(Group=="male" & Variable == "snp_1_169549811")) %>%  ## REMOVE THIS!!!!!!!!!!!!!!!!
    mutate(Pretty = factor(Pretty, levels=str_sort(unique(Pretty), numeric=TRUE))) %>%
    mutate(across(c(Pretty, Group), fct_rev)) %>%
    ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
    geom_vline(aes(xintercept=1), color="gray", size=1) +
    geom_rect(data=make_stripes(bayes_cis, "Pretty") %>% filter(stripe==1),
              mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                          ymin = as.numeric(Pretty) - 0.5),
              fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
    ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) + 
    labs(title="Bayesian", x="Odds ratio", y="Standardized variables", color = "Group") + 
    scale_colour_manual(values = cohort_colors) +
    scale_x_log10() +
    scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
  # Otherwise following error results: Error: Discrete value supplied to continuous scale
    theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
  return(g)
}

g <- helper(bayes_cis)
if (save_figs) {
  filename <- sprintf("%s/anemia_bayes_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```






## Try splines for some variables

```{r Define formulas with splines}
tmp <-as.character(bayes_formula)
tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3]) # Formula converted to a string
spline_variables <- c("age") #), "weight") # Make these variables use splines
spline_formula_str <- str_replace_all(tmp2, paste(spline_variables, collapse="|"), "s(\\0)")
# See here for combining interactions and splines:
# https://stats.stackexchange.com/questions/403772/different-ways-of-modelling-interactions-between-continuous-and-categorical-pred?rq=1
#spline_formula_str <- str_replace(spline_formula_str, fixed("blood_donor:s(weight)"), "s(weight, by=blood_donor, m=1)")
spline_formula <- as.formula(spline_formula_str)
print(spline_formula)
```

```{r}
spline_datas <-list(#all=data, 
             male=data_male, #female=data %>% filter(female),
             pre_menopausal_female=data_pre_menopausal_female,
             post_menopausal_female=data_post_menopausal_female)
spline_formulas <- list(#all=spline_formula_all, 
                          male=spline_formula, #female=spline_formula,
             pre_menopausal_female=spline_formula,
             post_menopausal_female=spline_formula)
```


### Fit models

```{r Fit all Bayesian spline models}
fit_bayesian_spline_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_spline_fit_%s.rds", data_path, group)
  if (recompute | !file.exists(filename)) {
    bayesian_fit <- brm(formula,
                            data = data, # %>% slice_sample(n=40000),   # REMOVE ME!!!!!
                            family = bernoulli(),
                            file = NULL,
                            control = list(max_treedepth = 15, adapt_delta = 0.99),
                            #refresh = 0,
                            cores = cores,
                        chains = 4,
                            #iter = 11000,
                            iter = 2000,
                            warmup = 500
    )
    saveRDS(bayesian_fit, filename)
  } else {
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}
#summary(bayesian_fit_all)
bayesian_spline_input <- tibble(group=setdiff(names(cohort_colors), c("all", "female")),
                         data=spline_datas,
                         formula=spline_formulas)
spline_fits <- pmap_dfr(bayesian_spline_input, fit_bayesian_spline_helper)
spline_fits_list <- deframe(spline_fits)
```


```{r Plot scaled splines}
#plot(conditional_smooths(spline_fit, smooths = "s(age)"), ask = FALSE)
helper <- function(fit) {
  x <- conditional_smooths(fit)
  bind_rows(
    #pivot_longer(x[[1]], cols = days_to_previous_fb),
    pivot_longer(x[[1]], cols = age)#,
    #pivot_longer(x[[2]], cols = weight)
  )
}
# Extract these from the fit for abline function.
helper2 <- function(fit) {
  t <- as_tibble(fit)
  df <- tribble(
    ~name, ~slope, ~intercept,
    #"days_to_previous_fb", mean(t$b_days_to_previous_fb), mean(t$b_Intercept),
    "age", mean(t$b_age), mean(t$b_Intercept)#,
    #"weight", mean(t$b_weight), mean(t$b_Intercept)
  )
  return(df)
}
x <- map_dfr(spline_fits_list, helper, .id="group")

plot_labeller <- function(group){
    case_when(group == "pre_menopausal_female" ~ "pre",
              group == "post_menopausal_female" ~ "post",
              TRUE ~ group)
}


line_coeffs <- map_dfr(bayesian_fits_list, helper2, .id="group") %>%
  filter(!group %in% c("all", "female")) %>%
  mutate(intercept = 0)  # Don't use these after all for comparability with the splines
g_scaled <- x %>% 
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), data = line_coeffs) +
  labs(title="IDA, scaled", y="s(value)") +
  #lims(y=c(-10, 5)) +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE, 
                     labeller = labeller(group=plot_labeller))
if (save_figs) {
  filename <- sprintf("%s/splines_scaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_scaled
```


```{r Plot unscaled splines}
g_unscaled <- x %>% inner_join(variable_stats, by=c("group", "name")) %>%
  mutate(value = value * sd + mean) %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), 
              data = line_coeffs %>% 
                left_join(variable_stats, by=c("group", "name")) %>% 
                mutate(intercept = -slope*mean/sd, slope = slope / sd)) +
  labs(title="IDA, unscaled", y="s(value)") +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE,
                     labeller = labeller(group=plot_labeller))
if (save_figs) {
  filename <- sprintf("%s/splines_unscaled.pdf", fig_path)
  ggsave(filename=filename, plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_unscaled
```

### Effect sizes

```{r}
filename <- sprintf("%s/anemia_spline_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  spline_cis <- pretty_bayes_intervals(spline_fits_list)
  write_tsv(spline_cis, file=filename)
} else {
  spline_cis <- read_tsv(filename)
}
```

```{r}
spline_comparison_cis <- bind_rows(linear=bayes_cis, spline=spline_cis, .id="Dependency")
g <- spline_comparison_cis %>%
  mutate(Dependency = fct_recode(Dependency, `non-linear`="spline")) %>%
  #filter(!(Pretty == "Smoking:Is blood donor" & Group == "post_menopausal_female")) %>%   # REMOVE THIS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  filter(Group %in% c("male", "pre_menopausal_female", "post_menopausal_female")) %>%
  mutate(Group = factor(Group, levels=c("male", "pre_menopausal_female", "post_menopausal_female"))) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  mutate(across(c(Dependency, Pretty), fct_rev)) %>%
  mutate(hollow_dependency=factor(if_else(low<=1 & high>=1, NA_character_, as.character(Dependency)),
                             levels=levels(Dependency))) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Dependency, fill=hollow_dependency)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
  ) +
  geom_stripes(bayes_cis %>% filter(Variable != "femaleTRUE"), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), size=0.2) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Linear vs spline dependency", 
       x="Odds ratio", y="Standardized variables") + 
  #scale_colour_manual(values = cohort_colors) +
  facet_wrap(~Group) +
  scale_color_discrete(breaks = c("linear", "non-linear"), na.value = "NA") +
  scale_fill_discrete(guide="none", na.value = "NA") +
  # scale_colour_manual(values = cohort_colors[names(cohort_colors) != "all"],
  #                     labels = cohort_names[names(cohort_names) != "all"], na.value = NA, drop=FALSE) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal")
if (save_figs) {
  filename <- sprintf("%s/anemia_linear_vs_spline.pdf", fig_path)
  ggsave(filename=filename, plot=g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}

g
```

## Combine confidence intervals from the two methods


```{r Compare confidence intervals of coefficients from frequentist and Bayesian method}
combined_cis <- bind_rows(Frequentist=freq_int_cis, Bayesian=bayes_cis, .id="Method")
g <- combined_cis %>% 
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=fct_rev(Pretty), color=Method)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Odds ratio", y="Standardized variables") +
  facet_wrap(~ Group)
g <- g + scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/cis_from_two_methods.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

# Survival analysis

```{r}
cox_variables <- setdiff(variables, "age")
cox_variables <- c(cox_variables, interactions)
```



```{r Get the anemia events}

longitudinal_filename <- "/finngen/library-red/finngen_R6/phenotype_2.0/data/finngen_R6_phenotype_endpoint_longitudinal_2.1"
#longitudinal_filename <- "/finngen/library-red/finngen_R6/phenotype_2.0/data/finngen_R6_v2_endpoint_longitudinal.gz"
longitudinal_anemia_filename <- sprintf("%s/anemia_longitudinal.tsv", data_path)
if (!file.exists(longitudinal_anemia_filename)) {
  cmd <- sprintf("cat %s | awk 'NR==1{print};{if ($6==\"D3_ANAEMIA_IRONDEF\") {print}}' > %s",
                 longitudinal_filename, longitudinal_anemia_filename)
  print(cmd)
  system(cmd)
}
```

```{r}
longitudinal <- read_tsv(longitudinal_anemia_filename) 
longitudinal <- longitudinal %>%
  mutate(across(c(FINNGENID, EVENT_TYPE, ICDVER, ENDPOINT), as.factor))
```

```{r}
summary(longitudinal %>% select(-FINNGENID))
```



```{r}
g <- count(longitudinal, FINNGENID) %>% ggplot(aes(x=n)) + 
  geom_histogram() + 
  scale_y_continuous(trans = "pseudo_log", 
                     breaks=c(1,10,100,1000,10000)
                     #breaks=breaks_log(5, base=10)
                     ) +
  labs(x="Number of anemia events")
if (allow_individual_level_data) g
```

## How are events from people with multiple events distributed in time

```{r}
# Order the ids by the decreasing count of events they have
bad_ids <- count(longitudinal, FINNGENID) %>% 
  arrange(desc(n)) %>% 
  mutate(anon_id = 1:nrow(.))
tmp <- bad_ids %>% filter(anon_id %in% 1:9)
g <-longitudinal %>% 
  inner_join(tmp, by="FINNGENID") %>%
  ggplot(aes(EVENT_AGE)) + geom_histogram() +
  geom_text(mapping=aes(label=sprintf("n=%i", n)), data=tmp, x=20, y=150) +
  facet_wrap(~anon_id)
if (save_figs) {
  filename <- sprintf("%s/highest_number_of_anemia_events.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}

if (allow_individual_level_data) g
```

Form time-to-event dataframe.

```{r}
survival_filename <- sprintf("%s/survival.rds", data_path)
if (recompute_survival | !file.exists(survival_filename)) {
  with_event <- longitudinal %>% 
    select(donor=FINNGENID, age=EVENT_AGE) %>%
    arrange(age) %>%
    group_by(donor) %>%
    slice_head(n=1) %>%   # Select the first anemia event only
    ungroup() %>%
    mutate(status=1)
  without_event <- finngen %>% 
    anti_join(with_event) %>%
    select(donor, age) %>%
    mutate(status=0)
  sur3 <- bind_rows(with_event, without_event)
  saveRDS(sur3, survival_filename)
} else {
  sur3 <- readRDS(survival_filename) %>% ungroup()
}
```

```{r}
head(sur3 %>% select(-donor))
summary(sur3 %>% mutate(status = as.factor(status)))
```


```{r}
#old_n <- nrow(sur3)
sur <- unfiltered_combined_data %>% select(-age) %>% # Remove the duplicate age column
  full_join(sur3, by="donor") %>%
  mutate(across(where(is.logical), as.factor))
#cat(sprintf("Dropping %i/%i rows due to combining with unfiltered_combined_data\n", old_n - nrow(sur), old_n))
```

```{r Drop missing values in survival}
cox_model_variables <- c("status", "age", setdiff(cox_variables, interactions))
cat(sprintf("Model variables are %s\n", paste(cox_model_variables, collapse=", ")))
exclusions_anemia_cox <- sur %>% summarise(across({{cox_model_variables}}, ~ sum(is.na(.))))
filename <- sprintf("%s/exclusions_anemia_cox.tsv", table_path)
if (save_tables) {
  write_tsv(exclusions_anemia_cox, filename)
}
t(exclusions_anemia_cox)
old_n <- nrow(sur)
sur <- sur %>% drop_na({{cox_model_variables}})
cat(sprintf("Dropping %i/%i rows due to NA in model variables\n", old_n - nrow(sur), old_n))
```

```{r}
sprintf("%i donors, %i events, %i censored", nrow(sur), sum(sur$status == 1), sum(sur$status == 0))
```

```{r Drop non-adults survival}
young_sur <- sur %>% filter(age < 18)
sur <- sur %>% filter(age >= 18) # Drop children
cat(sprintf("Dropped %i individuals because they were below 18 of age\n", nrow(young_sur)))
```

```{r}
sprintf("%i donors, %i events, %i censored", nrow(sur), sum(sur$status == 1), sum(sur$status == 0))
```

```{r}
s <- survival::Surv(sur$age, sur$status)
head(s)
```

```{r}
unscaled_sur_male   <- sur %>% filter(group == "male")
unscaled_sur_female <- sur %>% filter(group != "male")
unscaled_sur_pre_menopausal_female  <- sur %>% filter(group == "pre_menopausal_female")
unscaled_sur_post_menopausal_female <- sur %>% filter(group == "post_menopausal_female")
```

```{r}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("age", "status")) & !starts_with("snp_"), myscale))
}
scaled_sur        <- sur %>% scale_helper()
scaled_sur_male   <- unscaled_sur_male %>% scale_helper()
scaled_sur_female <- unscaled_sur_female %>% scale_helper()
scaled_sur_pre_menopausal_female  <- unscaled_sur_pre_menopausal_female %>% scale_helper()
scaled_sur_post_menopausal_female <- unscaled_sur_post_menopausal_female %>% scale_helper()
```



## Kaplan-Meier curve

```{r}
km_fit <- survival::survfit(Surv(age, status) ~ 1, data=sur)
autoplot(km_fit) + labs(x="Age", y="Survival from anemia")
ggsurvplot(km_fit, palette = "#2E9FDF", conf.int = TRUE, risk.table = TRUE, risk.table.y.text.col=TRUE)
```

```{r Stratify by sex}
ggsurvplot(survival::survfit(Surv(age, status) ~ female, data=sur), conf.int = TRUE, 
           #fun = "cumhaz",   # cumulative hazards instead of survival
           fun = NULL,
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by donor status}
ggsurvplot(survival::survfit(Surv(age, status) ~ blood_donor, data=sur), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```


```{r Stratify by RNF43 snip male}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_male), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769,
                             data=bind_rows(unscaled_sur_pre_menopausal_female,
                                            unscaled_sur_post_menopausal_female)), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip premenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, data=unscaled_sur_pre_menopausal_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip postmenopausal females}
ggsurvplot(survival::survfit(Surv(age, status) ~ snp_17_58358769, 
                             # There is only one homozygote with this snip
                             data=unscaled_sur_post_menopausal_female %>% filter(snp_17_58358769 != 2)), 
           conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r}
helper <- function(variable) {
  force(variable)
  form <- sprintf("Surv(age, status) ~ %s", variable)
  print(form)
  form <- as.formula(form)
  # Note! Below we need to use survminer::surv_fit instead of survival::survfit
  # To fix the following error https://github.com/kassambara/survminer/issues/252
  g <- ggsurvplot(
    #survival::survfit(form, data=sur), 
    survminer::surv_fit(form, data=sur), 
             #fun=fun, 
    legend = "right",
    legend.labs = 0:2,
    legend.title = "Dosage",
    censor = FALSE,
    conf.int = TRUE) 
             #risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
  #print("hullo")
  g + labs(title=variable, y="")
}
G <- map(snip_variables, helper)
# g1 <- helper("event")
# g2 <- helper(NULL)  # no transformation means the normal survival curve
# g3 <- helper("cumhaz")
g <- G[[1]]$plot / G[[2]]$plot / G[[3]]$plot / G[[4]]$plot + plot_layout(guides = 'collect') + 
  labs(y="Survival probability")
if (save_figs) {
  #filename <- sprintf("%s/pdf/deferral_kaplan_meyer.pdf", result_base)
  filename <- sprintf("%s/old_anemia_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g
#grid::grid.draw(grid::textGrob("Keno", x = 0.02, rot = 90))

#arrange_ggsurvplots(G, ncol=1, nrow=4)
```
```{r KM plots for article}
kaplan_meyer_helper <- function(variable, sur, smooth=FALSE) {
  smooth_helper <- function(df, key) {
    cat(sprintf("Variable %s, dosage %s, n=%i\n", key$variable, key$Dosage, nrow(df)))
    min_time <- min(df$time)
    max_time <- max(df$time)
    result <- tibble(time=seq(min_time, max_time, length.out = 100))
    for (variable2 in c("surv", "low", "high")) {
      form <- sprintf("%s ~ s(time, bs='cs')", variable2)
      form <- as.formula(form)
      
      gm <- mgcv::gam(form, data=df)
      
      result <- result %>% mutate({{variable2}} := as.vector(predict(gm, newdata=result)))
    }
    result
  }
  
  force(variable)
  form <- sprintf("Surv(age, status) ~ %s", variable)
  print(form)
  form <- as.formula(form)
  res <- survminer::surv_fit(form, data=sur)
  print(res$strata)
  df <- tibble(time=res$time, surv=res$surv, low=res$lower, high=res$upper,
               Dosage=factor(rep(0:(length(res$strata)-1), res$strata)),
               variable = variable)
  if (smooth) {
    df <- df %>% 
      group_by(Dosage, variable) %>%
      filter(n() > 100) %>%
      group_modify(smooth_helper) %>%
      ungroup() %>%
      mutate()
  }
  df
}
kaplan_meyer <- function(sur, smooth=FALSE) {
  res <- map_dfr(snip_variables, function(variable) kaplan_meyer_helper(variable, sur, smooth)) %>%
    mutate(variable = factor(variable, snip_variables)) %>%
    drop_na()
  res  
}
pretty_snips <- descript %>% filter(str_starts(Variable, "snp")) %>% select(Variable, Pretty) %>% deframe()
res <- kaplan_meyer(sur)
smoothed_res <- kaplan_meyer(sur, smooth=TRUE)
g <- res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  #pammtools::geom_stepribbon(alpha=0.2, color=NA) + # I could not easily install this on sandbox
  geom_ribbon(alpha=0.2, color=NA) +
  geom_step() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Age [years]", y="Survival")
smoothed_g <- smoothed_res %>% 
  ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
  geom_ribbon(alpha=0.2, color=NA) +
  geom_line() +
  facet_grid(rows=vars(variable), labeller=as_labeller(pretty_snips)) +
  labs(x="Age [years]", y="Survival")
g
smoothed_g
if (save_figs) {
  filename <- sprintf("%s/anemia_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
  filename <- sprintf("%s/smoothed_anemia_kaplan_meyer.pdf", fig_path)
  ggsave(filename=filename, smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
```


## Cox regression

```{r Define formulas}
cox_formula <- as.formula(sprintf("Surv(age, status) ~ %s", paste(setdiff(cox_variables, "female"), collapse=" + ")))
cox_formula_all <- as.formula(sprintf("Surv(age, status) ~ %s", paste(cox_variables, collapse=" + ")))
print(cox_formula)
print(cox_formula_all)
```

```{r Show data sizes}
helper <- function(data, group) {
  tmp <- data %>% drop_na(any_of(cox_variables))
  cat(sprintf("Cox PH model, group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
              group,
              nrow(tmp), 
              sum(tmp$status == 1), 
              sum(tmp$status == 0),
              100*sum(tmp$status == 1) / nrow(tmp)))
}
helper(scaled_sur, "all")
helper(scaled_sur_male, "male")
helper(scaled_sur_female, "female")
helper(scaled_sur_pre_menopausal_female, "pre_menopausal_female")
helper(scaled_sur_post_menopausal_female, "post_menopausal_female")
```

### Fit models

```{r}
filename <- sprintf("%s/cox_fits.rds", data_path)
if (recompute_survival | !file.exists(filename)) {
  #sur_female <- bind_rows(sur_pre_menopausal_female, sur_post_menopausal_female)
  cox_fit_all    <- survival::coxph(cox_formula_all, data=scaled_sur)
  cox_fit_male   <- survival::coxph(cox_formula, data=scaled_sur_male)
  cox_fit_female <- survival::coxph(cox_formula, data=scaled_sur_female)
  cox_fit_pre_menopausal_female  <- survival::coxph(cox_formula, data=scaled_sur_pre_menopausal_female)
  cox_fit_post_menopausal_female <- survival::coxph(cox_formula, data=scaled_sur_post_menopausal_female)
  
  cox_fit_list <- list(all=cox_fit_all, male=cox_fit_male, female=cox_fit_female,
                       pre_menopausal_female=cox_fit_pre_menopausal_female,
                       post_menopausal_female=cox_fit_post_menopausal_female)
  saveRDS(cox_fit_list, filename)
} else {
  cox_fit_list <- readRDS(filename)
  cox_fit_all    <- cox_fit_list$all
  cox_fit_male   <- cox_fit_list$male
  cox_fit_female <- cox_fit_list$female
  cox_fit_pre_menopausal_female  <- cox_fit_list$pre_menopausal_female
  cox_fit_post_menopausal_female <- cox_fit_list$post_menopausal_female
}
```


```{r}
g <- survminer::ggsurvplot(survfit(cox_fit_male), scaled_sur_male, risk.table = TRUE)
g
```

### Effect sizes


```{r}
get_cox_cis <- function(fit) {
  c3 <- rownames_to_column(as.data.frame(confint(fit)), var="Variable") %>% as_tibble()
  c4 <- rownames_to_column(as.data.frame(summary(fit)$coefficients), var="Variable") %>% as_tibble()
  c3 <- c3 %>% inner_join(c4, by="Variable")
  c <- c3 %>% 
    rename(Estimate = `coef`, low = `2.5 %`, high = `97.5 %`) %>%
    mutate(across(c(Estimate, low, high), exp))

  return(c)
  
}

```

```{r}
filename <- sprintf("%s/anemia_normal_cox_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  normal_cox_cis <- map_dfr(cox_fit_list, get_cox_cis, .id="Group") %>%  
    left_join(descript2, by=c(Variable = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors)))
  
  write_tsv(normal_cox_cis, file=filename)
} else {
  normal_cox_cis <- read_tsv(filename)
}
```

```{r Compare confidence intervals of normal Cox model on five strata}

g <- normal_cox_cis %>% 
  mutate(Group = fct_rev(Group)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=fct_rev(Pretty), color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_rect(data=make_stripes(normal_cox_cis, "Pretty") %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                        ymin = as.numeric(Pretty) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) + 
  labs(title="Cox model", x="Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
if (save_figs) {
  filename <- sprintf("%s/anemia_normal_cox_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```


### Diagnostics

See [diagnostics](http://www.sthda.com/english/wiki/cox-model-assumptions)

#### Check for proportional hazards assumption

Test the null hypothesis that the proportional hazards assumption holds.

Inclusion of anemia, ferritin and hemoglobin PRSs cause the next one to fail.

```{r Test for proportional hazards, eval=FALSE}
test_ph <- cox.zph(cox_fit_all)
test_ph
```

```{r, eval=FALSE}
g <- ggcoxzph(test_ph)
g
```

Some variables seem significant and therefore the proportional hazards assumption does not hold. Let's see if
stratification helps:


```{r Proportional assumption pvalues}
helper <- function(fit) { # Get p-values of variables from the fit
  survival::cox.zph(fit)$table %>% as.data.frame() %>% rownames_to_column(var="variable") %>% select(variable, p)
}
res <- map_dfr(cox_fit_list, helper, .id="model") %>% 
  pivot_wider(names_from = model, values_from=p)
pvalue_table(res)
```


#### Check for outliers

Its also possible to check outliers by visualizing the deviance residuals. The deviance residual is a normalized transform of the martingale residual. These residuals should be roughtly symmetrically distributed about zero with a standard deviation of 1.

*    Positive values correspond to individuals that died too soon compared to expected survival times.
*    Negative values correspond to individual that lived too long.
*    Very large or small values are outliers, which are poorly predicted by the model.


```{r, eval=FALSE}
ggcoxdiagnostics(cox_fit_all,
                 type = "deviance",
                 ox.scale = "linear.predictions")
```

For some reason the following doesn't work:

```{r, eval=FALSE}
g <- ggcoxdiagnostics(cox_fit_all,
                 type = "schoenfeld",
                 #type = "deviance",
                 ox.scale = "time")
g
```

#### Check for linearity of predictors

```{r}
tmp_fit <- survival::coxph(Surv(age, status) ~ bmi + log(bmi) + sqrt(bmi), data = sur %>% drop_na(bmi))
ggcoxfunctional(tmp_fit)#, data = sur_male %>% drop_na(bmi))
```

## Stratified Cox regression

Try if we can fix proportional assumption by stratifying by variable blood_donor.

```{r}
fixed_cox_formula <- as.formula(sprintf("Surv(age, status) ~ %s + strata(blood_donor)", paste(setdiff(cox_variables, c("female", "blood_donor")), collapse=" + ")))
fixed_cox_formula_all <- as.formula(sprintf("Surv(age, status) ~ %s + strata(blood_donor) + strata(female)", paste(setdiff(cox_variables, c("female", "blood_donor")), collapse=" + ")))
print(fixed_cox_formula)
print(fixed_cox_formula_all)
```

```{r Show data sizes in stratified Cox models}
helper <- function(data, group) {
  tmp <- data %>% drop_na(any_of(cox_variables))
  cat(sprintf("Cox PH model, group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
              group,
              nrow(tmp), 
              sum(tmp$status == 1), 
              sum(tmp$status == 0),
              100*sum(tmp$status == 1) / nrow(tmp)))
}
helper(scaled_sur, "all")
helper(scaled_sur_male, "male")
helper(scaled_sur_female, "female")
helper(scaled_sur_pre_menopausal_female, "pre_menopausal_female")
helper(scaled_sur_post_menopausal_female, "post_menopausal_female")
```

### Fit models

```{r}
fixed_cox_fit_all <- survival::coxph(fixed_cox_formula_all, data=scaled_sur)
fixed_cox_fit_male <- survival::coxph(fixed_cox_formula, data=scaled_sur_male)
fixed_cox_fit_female <- survival::coxph(fixed_cox_formula, data=scaled_sur_female)
fixed_cox_fit_pre_menopausal_female <- survival::coxph(fixed_cox_formula, data=scaled_sur_pre_menopausal_female)
fixed_cox_fit_post_menopausal_female <- survival::coxph(fixed_cox_formula, data=scaled_sur_post_menopausal_female)
fixed_cox_fit_list <- list(all=fixed_cox_fit_all, male=fixed_cox_fit_male, female=fixed_cox_fit_female,
                           pre_menopausal_female=fixed_cox_fit_pre_menopausal_female,
                           post_menopausal_female=fixed_cox_fit_post_menopausal_female)
```

After addition of PRS for hemoglobin and ferritin, the below doesn't work anymore.


### Diagnostics

```{r, eval=TRUE}
fixed_res <- map_dfr(fixed_cox_fit_list, helper, .id="model") %>% 
  pivot_wider(names_from = model, values_from=p)
pvalue_table(fixed_res)
```

So, it looks like that "female" and "blood_donor" variables can't be modeled, but can be stratified with.
Here, modeled means that the variable's HR is estimated. Stratified means that there are separate baseline hazard functions for the levels of the variable, but not HR's are estimated for it.

### Effect sizes

```{r Extract stratified Cox model results, eval=fix}

filename <- sprintf("%s/anemia_stratified_cox_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  stratified_cox_cis <- map_dfr(fixed_cox_fit_list, get_cox_cis, .id="Group") %>%  
    left_join(descript2, by=c(Variable = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), Variable, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Group = factor(Group, levels=names(cohort_colors)))
  
  write_tsv(stratified_cox_cis, file=filename)
} else {
  stratified_cox_cis <- read_tsv(filename)
}
```

```{r Compare confidence intervals of stratified Cox model on five strata, eval=fix}

stripes <- make_stripes(stratified_cox_cis , "Pretty")

g <- stratified_cox_cis %>% 
  mutate(across(c(Group, Pretty), fct_rev)) %>%
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  geom_rect(data=stripes %>% filter(stripe==1),
            mapping=aes(ymax = as.numeric(Pretty) + 0.5,
                        ymin = as.numeric(Pretty) - 0.5),
            fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) + 
  labs(title="Stratified Cox model", x="Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors) +
  scale_x_log10() +
  scale_y_discrete() + # !!!!! This is important. Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
                         # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
if (save_figs) {
  filename <- sprintf("%s/anemia_stratified_cox_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### Compare between stratified and non-stratified effect sizes

```{r Compare confidence intervals of coefficients from normal and stratified Cox model, eval=fix}
combined_cox_cis <- bind_rows(Normal=normal_cox_cis, Stratified=stratified_cox_cis, .id="Method")
g <- combined_cox_cis %>% 
  ggplot(aes(x=Estimate, xmin=low, xmax=high, y=fct_rev(Pretty), color=Method)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
  labs(x="Hazard ratio", y="Standardized variables") +
  facet_wrap(~ Group) + scale_x_log10()

if (save_figs) {
  filename <- sprintf("%s/cis_from_two_cox_methods.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

Results didn't change much, except for BMI and Smoking variables in group all. Hence,
we will use normal (non-stratified) Cox model, as it is simpler.




## Bayesian survival

```{r Bayesian survival, eval=FALSE}
#cox_fit_male <- survival::coxph(cox_formula, data=sur_male)
bayesian_cox <- brm(cox_formula,                     
    data = sur %>% filter(age >= 5), 
    family = cox(),
    file = NULL,
    control = list(max_treedepth = 15),
    cores = cores,
    iter = iterations)
```




